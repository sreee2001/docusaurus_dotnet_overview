"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[8937],{6242:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Topics/Security/JWTTokens","title":"JWTTokens","description":"50. JWT Tokens","source":"@site/docs/Topics/11_Security/50_JWTTokens.md","sourceDirName":"Topics/11_Security","slug":"/Topics/Security/JWTTokens","permalink":"/docusaurus_dotnet_overview/docs/Topics/Security/JWTTokens","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":50,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"OAuthAndOpenIDConnect","permalink":"/docusaurus_dotnet_overview/docs/Topics/Security/OAuthAndOpenIDConnect"},"next":{"title":"Https_and_TLS","permalink":"/docusaurus_dotnet_overview/docs/Topics/Security/Https_and_TLS"}}');var s=r(4848),i=r(8453);const o={},a=void 0,c={},l=[{value:"50. JWT Tokens",id:"50-jwt-tokens",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Official Definition",id:"official-definition",level:2},{value:"Usage &amp; Setup",id:"usage--setup",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Market Alternatives &amp; Adoption",id:"market-alternatives--adoption",level:3},{value:"Alternatives:",id:"alternatives",level:3},{value:"Pros and Cons",id:"pros-and-cons",level:3},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Sample Implementation",id:"sample-implementation",level:3}];function u(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"50-jwt-tokens",children:"50. JWT Tokens"}),"\n",(0,s.jsx)(n.h3,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"JSON Web Tokens (JWT) are a compact, URL-safe means of representing claims to be transferred between two parties. JWTs are commonly used for authentication and information exchange in modern web applications and APIs."}),"\n",(0,s.jsx)(n.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,s.jsx)(n.p,{children:"JWT is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed using a secret (HMAC) or a public/private key pair (RSA or ECDSA)."}),"\n",(0,s.jsx)(n.h3,{id:"usage--setup",children:"Usage & Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Install JWT packages\r\ndotnet add package System.IdentityModel.Tokens.Jwt\r\ndotnet add package Microsoft.AspNetCore.Authentication.JwtBearer\r\ndotnet add package Microsoft.IdentityModel.Tokens\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Program.cs - JWT Configuration\r\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\r\nusing Microsoft.IdentityModel.Tokens;\r\nusing System.Text;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// JWT Configuration\r\nvar jwtSettings = builder.Configuration.GetSection("JwtSettings");\r\nvar secretKey = jwtSettings["SecretKey"];\r\nvar issuer = jwtSettings["Issuer"];\r\nvar audience = jwtSettings["Audience"];\r\n\r\nbuilder.Services.AddAuthentication(options =>\r\n{\r\n    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\r\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\r\n})\r\n.AddJwtBearer(options =>\r\n{\r\n    options.TokenValidationParameters = new TokenValidationParameters\r\n    {\r\n        ValidateIssuer = true,\r\n        ValidateAudience = true,\r\n        ValidateLifetime = true,\r\n        ValidateIssuerSigningKey = true,\r\n        ValidIssuer = issuer,\r\n        ValidAudience = audience,\r\n        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)),\r\n        ClockSkew = TimeSpan.Zero // Remove default 5-minute tolerance\r\n    };\r\n\r\n    options.Events = new JwtBearerEvents\r\n    {\r\n        OnAuthenticationFailed = context =>\r\n        {\r\n            if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))\r\n            {\r\n                context.Response.Headers.Add("Token-Expired", "true");\r\n            }\r\n            return Task.CompletedTask;\r\n        }\r\n    };\r\n});\r\n\r\nvar app = builder.Build();\r\napp.UseAuthentication();\r\napp.UseAuthorization();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stateless API authentication"}),"\n",(0,s.jsx)(n.li,{children:"Single Sign-On (SSO) implementations"}),"\n",(0,s.jsx)(n.li,{children:"Microservices security"}),"\n",(0,s.jsx)(n.li,{children:"Mobile application authentication"}),"\n",(0,s.jsx)(n.li,{children:"Cross-domain authentication"}),"\n",(0,s.jsx)(n.li,{children:"Information exchange between services"}),"\n",(0,s.jsx)(n.li,{children:"Session management alternative"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use When:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Building stateless APIs"}),"\n",(0,s.jsx)(n.li,{children:"Implementing distributed systems"}),"\n",(0,s.jsx)(n.li,{children:"Need cross-domain authentication"}),"\n",(0,s.jsx)(n.li,{children:"Mobile/SPA applications"}),"\n",(0,s.jsx)(n.li,{children:"Microservices architecture"}),"\n",(0,s.jsx)(n.li,{children:"Performance is critical"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Don't Use When:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sensitive data needs to be stored"}),"\n",(0,s.jsx)(n.li,{children:"Tokens can't be revoked easily"}),"\n",(0,s.jsx)(n.li,{children:"Network security is poor"}),"\n",(0,s.jsx)(n.li,{children:"Simple session-based auth suffices"}),"\n",(0,s.jsx)(n.li,{children:"Real-time revocation is required"}),"\n",(0,s.jsx)(n.li,{children:"Token size becomes problematic"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"market-alternatives--adoption",children:"Market Alternatives & Adoption"}),"\n",(0,s.jsx)(n.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Session-based authentication"}),"\n",(0,s.jsx)(n.li,{children:"OAuth 2.0 access tokens"}),"\n",(0,s.jsx)(n.li,{children:"SAML tokens"}),"\n",(0,s.jsx)(n.li,{children:"API keys"}),"\n",(0,s.jsx)(n.li,{children:"Cookies with server sessions"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Market Position:"})," De facto standard for modern API authentication, adopted by major platforms and frameworks worldwide."]}),"\n",(0,s.jsx)(n.h3,{id:"pros-and-cons",children:"Pros and Cons"}),"\n",(0,s.jsx)(n.h3,{id:"pros",children:"Pros:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stateless and scalable"}),"\n",(0,s.jsx)(n.li,{children:"Self-contained with claims"}),"\n",(0,s.jsx)(n.li,{children:"Cross-domain support"}),"\n",(0,s.jsx)(n.li,{children:"JSON format (widely supported)"}),"\n",(0,s.jsx)(n.li,{children:"Compact size"}),"\n",(0,s.jsx)(n.li,{children:"Cryptographically signed"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"cons",children:"Cons:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cannot be revoked easily"}),"\n",(0,s.jsx)(n.li,{children:"Token size can grow large"}),"\n",(0,s.jsx)(n.li,{children:"Secret key management critical"}),"\n",(0,s.jsx)(n.li,{children:"No built-in refresh mechanism"}),"\n",(0,s.jsx)(n.li,{children:"Clock synchronization issues"}),"\n",(0,s.jsx)(n.li,{children:"Base64 encoding (not encryption)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sample-implementation",children:"Sample Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Models/JwtModels.cs\r\npublic class JwtSettings\r\n{\r\n    public string SecretKey { get; set; }\r\n    public string Issuer { get; set; }\r\n    public string Audience { get; set; }\r\n    public int ExpirationMinutes { get; set; }\r\n    public int RefreshTokenExpirationDays { get; set; }\r\n}\r\n\r\npublic class LoginRequest\r\n{\r\n    [Required]\r\n    [EmailAddress]\r\n    public string Email { get; set; }\r\n\r\n    [Required]\r\n    public string Password { get; set; }\r\n}\r\n\r\npublic class AuthResponse\r\n{\r\n    public string AccessToken { get; set; }\r\n    public string RefreshToken { get; set; }\r\n    public DateTime Expiration { get; set; }\r\n    public UserInfo User { get; set; }\r\n}\r\n\r\npublic class UserInfo\r\n{\r\n    public string Id { get; set; }\r\n    public string Email { get; set; }\r\n    public string FirstName { get; set; }\r\n    public string LastName { get; set; }\r\n    public List<string> Roles { get; set; }\r\n}\r\n\r\npublic class RefreshToken\r\n{\r\n    public string Id { get; set; }\r\n    public string UserId { get; set; }\r\n    public string Token { get; set; }\r\n    public DateTime ExpiryDate { get; set; }\r\n    public bool IsRevoked { get; set; }\r\n    public DateTime CreatedDate { get; set; }\r\n    public string CreatedByIp { get; set; }\r\n    public DateTime? RevokedDate { get; set; }\r\n    public string RevokedByIp { get; set; }\r\n    public string ReplacedByToken { get; set; }\r\n}\r\n\r\n// Services/IJwtService.cs\r\npublic interface IJwtService\r\n{\r\n    string GenerateAccessToken(ApplicationUser user, IList<string> roles);\r\n    RefreshToken GenerateRefreshToken(string userId, string ipAddress);\r\n    ClaimsPrincipal ValidateToken(string token);\r\n    Task<AuthResponse> RefreshTokenAsync(string token, string ipAddress);\r\n    Task RevokeTokenAsync(string token, string ipAddress);\r\n    Task<bool> IsTokenValidAsync(string token);\r\n}\r\n\r\n// Services/JwtService.cs\r\npublic class JwtService : IJwtService\r\n{\r\n    private readonly JwtSettings _jwtSettings;\r\n    private readonly UserManager<ApplicationUser> _userManager;\r\n    private readonly ApplicationDbContext _context;\r\n    private readonly ILogger<JwtService> _logger;\r\n\r\n    public JwtService(\r\n        IOptions<JwtSettings> jwtSettings,\r\n        UserManager<ApplicationUser> userManager,\r\n        ApplicationDbContext context,\r\n        ILogger<JwtService> logger)\r\n    {\r\n        _jwtSettings = jwtSettings.Value;\r\n        _userManager = userManager;\r\n        _context = context;\r\n        _logger = logger;\r\n    }\r\n\r\n    public string GenerateAccessToken(ApplicationUser user, IList<string> roles)\r\n    {\r\n        var claims = new List<Claim>\r\n        {\r\n            new Claim(JwtRegisteredClaimNames.Sub, user.Id),\r\n            new Claim(JwtRegisteredClaimNames.Email, user.Email),\r\n            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),\r\n            new Claim(JwtRegisteredClaimNames.Iat,\r\n                new DateTimeOffset(DateTime.UtcNow).ToUnixTimeSeconds().ToString(),\r\n                ClaimValueTypes.Integer64),\r\n            new Claim("firstName", user.FirstName ?? ""),\r\n            new Claim("lastName", user.LastName ?? ""),\r\n            new Claim("userId", user.Id)\r\n        };\r\n\r\n        // Add role claims\r\n        foreach (var role in roles)\r\n        {\r\n            claims.Add(new Claim(ClaimTypes.Role, role));\r\n        }\r\n\r\n        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));\r\n        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\r\n\r\n        var token = new JwtSecurityToken(\r\n            issuer: _jwtSettings.Issuer,\r\n            audience: _jwtSettings.Audience,\r\n            claims: claims,\r\n            expires: DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),\r\n            signingCredentials: credentials\r\n        );\r\n\r\n        return new JwtSecurityTokenHandler().WriteToken(token);\r\n    }\r\n\r\n    public RefreshToken GenerateRefreshToken(string userId, string ipAddress)\r\n    {\r\n        using var rngCryptoServiceProvider = new RNGCryptoServiceProvider();\r\n        var randomBytes = new byte[64];\r\n        rngCryptoServiceProvider.GetBytes(randomBytes);\r\n\r\n        return new RefreshToken\r\n        {\r\n            Id = Guid.NewGuid().ToString(),\r\n            UserId = userId,\r\n            Token = Convert.ToBase64String(randomBytes),\r\n            ExpiryDate = DateTime.UtcNow.AddDays(_jwtSettings.RefreshTokenExpirationDays),\r\n            CreatedDate = DateTime.UtcNow,\r\n            CreatedByIp = ipAddress\r\n        };\r\n    }\r\n\r\n    public ClaimsPrincipal ValidateToken(string token)\r\n    {\r\n        var tokenHandler = new JwtSecurityTokenHandler();\r\n        var key = Encoding.UTF8.GetBytes(_jwtSettings.SecretKey);\r\n\r\n        try\r\n        {\r\n            var principal = tokenHandler.ValidateToken(token, new TokenValidationParameters\r\n            {\r\n                ValidateIssuerSigningKey = true,\r\n                IssuerSigningKey = new SymmetricSecurityKey(key),\r\n                ValidateIssuer = true,\r\n                ValidIssuer = _jwtSettings.Issuer,\r\n                ValidateAudience = true,\r\n                ValidAudience = _jwtSettings.Audience,\r\n                ValidateLifetime = true,\r\n                ClockSkew = TimeSpan.Zero\r\n            }, out SecurityToken validatedToken);\r\n\r\n            return principal;\r\n        }\r\n        catch\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public async Task<AuthResponse> RefreshTokenAsync(string token, string ipAddress)\r\n    {\r\n        var refreshToken = await _context.RefreshTokens\r\n            .FirstOrDefaultAsync(rt => rt.Token == token && !rt.IsRevoked);\r\n\r\n        if (refreshToken == null || refreshToken.ExpiryDate <= DateTime.UtcNow)\r\n        {\r\n            throw new SecurityTokenException("Invalid or expired refresh token");\r\n        }\r\n\r\n        var user = await _userManager.FindByIdAsync(refreshToken.UserId);\r\n        if (user == null)\r\n        {\r\n            throw new SecurityTokenException("User not found");\r\n        }\r\n\r\n        // Revoke current refresh token\r\n        refreshToken.IsRevoked = true;\r\n        refreshToken.RevokedDate = DateTime.UtcNow;\r\n        refreshToken.RevokedByIp = ipAddress;\r\n\r\n        // Generate new tokens\r\n        var roles = await _userManager.GetRolesAsync(user);\r\n        var newAccessToken = GenerateAccessToken(user, roles);\r\n        var newRefreshToken = GenerateRefreshToken(user.Id, ipAddress);\r\n\r\n        // Replace old token\r\n        refreshToken.ReplacedByToken = newRefreshToken.Token;\r\n\r\n        _context.RefreshTokens.Add(newRefreshToken);\r\n        await _context.SaveChangesAsync();\r\n\r\n        return new AuthResponse\r\n        {\r\n            AccessToken = newAccessToken,\r\n            RefreshToken = newRefreshToken.Token,\r\n            Expiration = DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),\r\n            User = new UserInfo\r\n            {\r\n                Id = user.Id,\r\n                Email = user.Email,\r\n                FirstName = user.FirstName,\r\n                LastName = user.LastName,\r\n                Roles = roles.ToList()\r\n            }\r\n        };\r\n    }\r\n\r\n    public async Task RevokeTokenAsync(string token, string ipAddress)\r\n    {\r\n        var refreshToken = await _context.RefreshTokens\r\n            .FirstOrDefaultAsync(rt => rt.Token == token);\r\n\r\n        if (refreshToken == null)\r\n        {\r\n            throw new SecurityTokenException("Token not found");\r\n        }\r\n\r\n        refreshToken.IsRevoked = true;\r\n        refreshToken.RevokedDate = DateTime.UtcNow;\r\n        refreshToken.RevokedByIp = ipAddress;\r\n\r\n        await _context.SaveChangesAsync();\r\n    }\r\n\r\n    public async Task<bool> IsTokenValidAsync(string token)\r\n    {\r\n        var refreshToken = await _context.RefreshTokens\r\n            .FirstOrDefaultAsync(rt => rt.Token == token);\r\n\r\n        return refreshToken != null &&\r\n               !refreshToken.IsRevoked &&\r\n               refreshToken.ExpiryDate > DateTime.UtcNow;\r\n    }\r\n}\r\n\r\n// Controllers/AuthController.cs\r\n[ApiController]\r\n[Route("api/[controller]")]\r\npublic class AuthController : ControllerBase\r\n{\r\n    private readonly IJwtService _jwtService;\r\n    private readonly UserManager<ApplicationUser> _userManager;\r\n    private readonly SignInManager<ApplicationUser> _signInManager;\r\n    private readonly ILogger<AuthController> _logger;\r\n\r\n    public AuthController(\r\n        IJwtService jwtService,\r\n        UserManager<ApplicationUser> userManager,\r\n        SignInManager<ApplicationUser> signInManager,\r\n        ILogger<AuthController> logger)\r\n    {\r\n        _jwtService = jwtService;\r\n        _userManager = userManager;\r\n        _signInManager = signInManager;\r\n        _logger = logger;\r\n    }\r\n\r\n    [HttpPost("login")]\r\n    public async Task<ActionResult<AuthResponse>> Login([FromBody] LoginRequest request)\r\n    {\r\n        try\r\n        {\r\n            var user = await _userManager.FindByEmailAsync(request.Email);\r\n            if (user == null)\r\n            {\r\n                return Unauthorized(new { message = "Invalid credentials" });\r\n            }\r\n\r\n            var result = await _signInManager.CheckPasswordSignInAsync(user, request.Password, false);\r\n            if (!result.Succeeded)\r\n            {\r\n                return Unauthorized(new { message = "Invalid credentials" });\r\n            }\r\n\r\n            var roles = await _userManager.GetRolesAsync(user);\r\n            var accessToken = _jwtService.GenerateAccessToken(user, roles);\r\n            var refreshToken = _jwtService.GenerateRefreshToken(user.Id, GetIpAddress());\r\n\r\n            // Save refresh token to database\r\n            var context = HttpContext.RequestServices.GetRequiredService<ApplicationDbContext>();\r\n            context.RefreshTokens.Add(refreshToken);\r\n            await context.SaveChangesAsync();\r\n\r\n            var response = new AuthResponse\r\n            {\r\n                AccessToken = accessToken,\r\n                RefreshToken = refreshToken.Token,\r\n                Expiration = DateTime.UtcNow.AddMinutes(60), // Based on your JWT settings\r\n                User = new UserInfo\r\n                {\r\n                    Id = user.Id,\r\n                    Email = user.Email,\r\n                    FirstName = user.FirstName,\r\n                    LastName = user.LastName,\r\n                    Roles = roles.ToList()\r\n                }\r\n            };\r\n\r\n            _logger.LogInformation("User {Email} logged in successfully", user.Email);\r\n            return Ok(response);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Login failed for {Email}", request.Email);\r\n            return StatusCode(500, new { message = "An error occurred during login" });\r\n        }\r\n    }\r\n\r\n    [HttpPost("refresh-token")]\r\n    public async Task<ActionResult<AuthResponse>> RefreshToken([FromBody] RefreshTokenRequest request)\r\n    {\r\n        try\r\n        {\r\n            var response = await _jwtService.RefreshTokenAsync(request.RefreshToken, GetIpAddress());\r\n            return Ok(response);\r\n        }\r\n        catch (SecurityTokenException ex)\r\n        {\r\n            return Unauthorized(new { message = ex.Message });\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Token refresh failed");\r\n            return StatusCode(500, new { message = "An error occurred during token refresh" });\r\n        }\r\n    }\r\n\r\n    [HttpPost("revoke-token")]\r\n    [Authorize]\r\n    public async Task<IActionResult> RevokeToken([FromBody] RevokeTokenRequest request)\r\n    {\r\n        try\r\n        {\r\n            await _jwtService.Revo// Models/JwtModels.cs\r\npublic class JwtSettings\r\n{\r\n    public string SecretKey { get; set; }\r\n    public string Issuer { get; set; }\r\n    public string Audience { get; set; }\r\n    public int ExpirationMinutes { get; set; }\r\n    public int RefreshTokenExpirationDays { get; set; }\r\n}\r\n\r\npublic class LoginRequest\r\n{\r\n    [Required]\r\n    [EmailAddress]\r\n    public string Email { get; set; }\r\n\r\n    [Required]\r\n    public string Password { get; set; }\r\n}\r\n\r\npublic class AuthResponse\r\n{\r\n    public string AccessToken { get; set; }\r\n    public string RefreshToken { get; set; }\r\n    public DateTime Expiration { get; set; }\r\n    public UserInfo User { get; set; }\r\n}\r\n\r\npublic class UserInfo\r\n{\r\n    public string Id { get; set; }\r\n    public string Email { get; set; }\r\n    public string FirstName { get; set; }\r\n    public string LastName { get; set; }\r\n    public List<string> Roles { get; set; }\r\n}\r\n\r\npublic class RefreshToken\r\n{\r\n    public string Id { get; set; }\r\n    public string UserId { get; set; }\r\n    public string Token { get; set; }\r\n    public DateTime ExpiryDate { get; set; }\r\n    public bool IsRevoked { get; set; }\r\n    public DateTime CreatedDate { get; set; }\r\n    public string CreatedByIp { get; set; }\r\n    public DateTime? RevokedDate { get; set; }\r\n    public string RevokedByIp { get; set; }\r\n    public string ReplacedByToken { get; set; }\r\n}\r\n\r\n// Services/IJwtService.cs\r\npublic interface IJwtService\r\n{\r\n    string GenerateAccessToken(ApplicationUser user, IList<string> roles);\r\n    RefreshToken GenerateRefreshToken(string userId, string ipAddress);\r\n    ClaimsPrincipal ValidateToken(string token);\r\n    Task<AuthResponse> RefreshTokenAsync(string token, string ipAddress);\r\n    Task RevokeTokenAsync(string token, string ipAddress);\r\n    Task<bool> IsTokenValidAsync(string token);\r\n}\r\n\r\n// Services/JwtService.cs\r\npublic class JwtService : IJwtService\r\n{\r\n    private readonly JwtSettings _jwtSettings;\r\n    private readonly UserManager<ApplicationUser> _userManager;\r\n    private readonly ApplicationDbContext _context;\r\n    private readonly ILogger<JwtService> _logger;\r\n\r\n    public JwtService(\r\n        IOptions<JwtSettings> jwtSettings,\r\n        UserManager<ApplicationUser> userManager,\r\n        ApplicationDbContext context,\r\n        ILogger<JwtService> logger)\r\n    {\r\n        _jwtSettings = jwtSettings.Value;\r\n        _userManager = userManager;\r\n        _context = context;\r\n        _logger = logger;\r\n    }\r\n\r\n    public string GenerateAccessToken(ApplicationUser user, IList<string> roles)\r\n    {\r\n        var claims = new List<Claim>\r\n        {\r\n            new Claim(JwtRegisteredClaimNames.Sub, user.Id),\r\n            new Claim(JwtRegisteredClaimNames.Email, user.Email),\r\n            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),\r\n            new Claim(JwtRegisteredClaimNames.Iat,\r\n                new DateTimeOffset(DateTime.UtcNow).ToUnixTimeSeconds().ToString(),\r\n                ClaimValueTypes.Integer64),\r\n            new Claim("firstName", user.FirstName ?? ""),\r\n            new Claim("lastName", user.LastName ?? ""),\r\n            new Claim("userId", user.Id)\r\n        };\r\n\r\n        // Add role claims\r\n        foreach (var role in roles)\r\n        {\r\n            claims.Add(new Claim(ClaimTypes.Role, role));\r\n        }\r\n\r\n        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));\r\n        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\r\n\r\n        var token = new JwtSecurityToken(\r\n            issuer: _jwtSettings.Issuer,\r\n            audience: _jwtSettings.Audience,\r\n            claims: claims,\r\n            expires: DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),\r\n            signingCredentials: credentials\r\n        );\r\n\r\n        return new JwtSecurityTokenHandler().WriteToken(token);\r\n    }\r\n\r\n    public RefreshToken GenerateRefreshToken(string userId, string ipAddress)\r\n    {\r\n        using var rngCryptoServiceProvider = new RNGCryptoServiceProvider();\r\n        var randomBytes = new byte[64];\r\n        rngCryptoServiceProvider.GetBytes(randomBytes);\r\n\r\n        return new RefreshToken\r\n        {\r\n            Id = Guid.NewGuid().ToString(),\r\n            UserId = userId,\r\n            Token = Convert.ToBase64String(randomBytes),\r\n            ExpiryDate = DateTime.UtcNow.AddDays(_jwtSettings.RefreshTokenExpirationDays),\r\n            CreatedDate = DateTime.UtcNow,\r\n            CreatedByIp = ipAddress\r\n        };\r\n    }\r\n\r\n    public ClaimsPrincipal ValidateToken(string token)\r\n    {\r\n        var tokenHandler = new JwtSecurityTokenHandler();\r\n        var key = Encoding.UTF8.GetBytes(_jwtSettings.SecretKey);\r\n\r\n        try\r\n        {\r\n            var principal = tokenHandler.ValidateToken(token, new TokenValidationParameters\r\n            {\r\n                ValidateIssuerSigningKey = true,\r\n                IssuerSigningKey = new SymmetricSecurityKey(key),\r\n                ValidateIssuer = true,\r\n                ValidIssuer = _jwtSettings.Issuer,\r\n                ValidateAudience = true,\r\n                ValidAudience = _jwtSettings.Audience,\r\n                ValidateLifetime = true,\r\n                ClockSkew = TimeSpan.Zero\r\n            }, out SecurityToken validatedToken);\r\n\r\n            return principal;\r\n        }\r\n        catch\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public async Task<AuthResponse> RefreshTokenAsync(string token, string ipAddress)\r\n    {\r\n        var refreshToken = await _context.RefreshTokens\r\n            .FirstOrDefaultAsync(rt => rt.Token == token && !rt.IsRevoked);\r\n\r\n        if (refreshToken == null || refreshToken.ExpiryDate <= DateTime.UtcNow)\r\n        {\r\n            throw new SecurityTokenException("Invalid or expired refresh token");\r\n        }\r\n\r\n        var user = await _userManager.FindByIdAsync(refreshToken.UserId);\r\n        if (user == null)\r\n        {\r\n            throw new SecurityTokenException("User not found");\r\n        }\r\n\r\n        // Revoke current refresh token\r\n        refreshToken.IsRevoked = true;\r\n        refreshToken.RevokedDate = DateTime.UtcNow;\r\n        refreshToken.RevokedByIp = ipAddress;\r\n\r\n        // Generate new tokens\r\n        var roles = await _userManager.GetRolesAsync(user);\r\n        var newAccessToken = GenerateAccessToken(user, roles);\r\n        var newRefreshToken = GenerateRefreshToken(user.Id, ipAddress);\r\n\r\n        // Replace old token\r\n        refreshToken.ReplacedByToken = newRefreshToken.Token;\r\n\r\n        _context.RefreshTokens.Add(newRefreshToken);\r\n        await _context.SaveChangesAsync();\r\n\r\n        return new AuthResponse\r\n        {\r\n            AccessToken = newAccessToken,\r\n            RefreshToken = newRefreshToken.Token,\r\n            Expiration = DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),\r\n            User = new UserInfo\r\n            {\r\n                Id = user.Id,\r\n                Email = user.Email,\r\n                FirstName = user.FirstName,\r\n                LastName = user.LastName,\r\n                Roles = roles.ToList()\r\n            }\r\n        };\r\n    }\r\n\r\n    public async Task RevokeTokenAsync(string token, string ipAddress)\r\n    {\r\n        var refreshToken = await _context.RefreshTokens\r\n            .FirstOrDefaultAsync(rt => rt.Token == token);\r\n\r\n        if (refreshToken == null)\r\n        {\r\n            throw new SecurityTokenException("Token not found");\r\n        }\r\n\r\n        refreshToken.IsRevoked = true;\r\n        refreshToken.RevokedDate = DateTime.UtcNow;\r\n        refreshToken.RevokedByIp = ipAddress;\r\n\r\n        await _context.SaveChangesAsync();\r\n    }\r\n\r\n    public async Task<bool> IsTokenValidAsync(string token)\r\n    {\r\n        var refreshToken = await _context.RefreshTokens\r\n            .FirstOrDefaultAsync(rt => rt.Token == token);\r\n\r\n        return refreshToken != null &&\r\n               !refreshToken.IsRevoked &&\r\n               refreshToken.ExpiryDate > DateTime.UtcNow;\r\n    }\r\n}\r\n\r\n// Controllers/AuthController.cs\r\n[ApiController]\r\n[Route("api/[controller]")]\r\npublic class AuthController : ControllerBase\r\n{\r\n    private readonly IJwtService _jwtService;\r\n    private readonly UserManager<ApplicationUser> _userManager;\r\n    private readonly SignInManager<ApplicationUser> _signInManager;\r\n    private readonly ILogger<AuthController> _logger;\r\n\r\n    public AuthController(\r\n        IJwtService jwtService,\r\n        UserManager<ApplicationUser> userManager,\r\n        SignInManager<ApplicationUser> signInManager,\r\n        ILogger<AuthController> logger)\r\n    {\r\n        _jwtService = jwtService;\r\n        _userManager = userManager;\r\n        _signInManager = signInManager;\r\n        _logger = logger;\r\n    }\r\n\r\n    [HttpPost("login")]\r\n    public async Task<ActionResult<AuthResponse>> Login([FromBody] LoginRequest request)\r\n    {\r\n        try\r\n        {\r\n            var user = await _userManager.FindByEmailAsync(request.Email);\r\n            if (user == null)\r\n            {\r\n                return Unauthorized(new { message = "Invalid credentials" });\r\n            }\r\n\r\n            var result = await _signInManager.CheckPasswordSignInAsync(user, request.Password, false);\r\n            if (!result.Succeeded)\r\n            {\r\n                return Unauthorized(new { message = "Invalid credentials" });\r\n            }\r\n\r\n            var roles = await _userManager.GetRolesAsync(user);\r\n            var accessToken = _jwtService.GenerateAccessToken(user, roles);\r\n            var refreshToken = _jwtService.GenerateRefreshToken(user.Id, GetIpAddress());\r\n\r\n            // Save refresh token to database\r\n            var context = HttpContext.RequestServices.GetRequiredService<ApplicationDbContext>();\r\n            context.RefreshTokens.Add(refreshToken);\r\n            await context.SaveChangesAsync();\r\n\r\n            var response = new AuthResponse\r\n            {\r\n                AccessToken = accessToken,\r\n                RefreshToken = refreshToken.Token,\r\n                Expiration = DateTime.UtcNow.AddMinutes(60), // Based on your JWT settings\r\n                User = new UserInfo\r\n                {\r\n                    Id = user.Id,\r\n                    Email = user.Email,\r\n                    FirstName = user.FirstName,\r\n                    LastName = user.LastName,\r\n                    Roles = roles.ToList()\r\n                }\r\n            };\r\n\r\n            _logger.LogInformation("User {Email} logged in successfully", user.Email);\r\n            return Ok(response);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Login failed for {Email}", request.Email);\r\n            return StatusCode(500, new { message = "An error occurred during login" });\r\n        }\r\n    }\r\n\r\n    [HttpPost("refresh-token")]\r\n    public async Task<ActionResult<AuthResponse>> RefreshToken([FromBody] RefreshTokenRequest request)\r\n    {\r\n        try\r\n        {\r\n            var response = await _jwtService.RefreshTokenAsync(request.RefreshToken, GetIpAddress());\r\n            return Ok(response);\r\n        }\r\n        catch (SecurityTokenException ex)\r\n        {\r\n            return Unauthorized(new { message = ex.Message });\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Token refresh failed");\r\n            return StatusCode(500, new { message = "An error occurred during token refresh" });\r\n        }\r\n    }\r\n\r\n    [HttpPost("revoke-token")]\r\n    [Authorize]\r\n    public async Task<IActionResult> RevokeToken([FromBody] RevokeTokenRequest request)\r\n    {\r\n        try\r\n        {\r\n            await _jwtService.Revo\r\n\r\nSimilar code found with 4 license types\r\n\r\nsreee2001: please continue from after\r\n\r\n [HttpPost("refresh-token")]\r\n    public async Task<ActionResult<AuthResponse>> RefreshToken([FromBody] RefreshTokenRequest request)\r\n    {\r\n        try\r\n        {\r\n            var response = await _jwtService.RefreshTokenAsync(request.RefreshToken, GetIpAddress());\r\n            return Ok(response);\r\n        }\r\n        catch (SecurityTokenException ex)\r\n        {\r\n            return Unauthorized(new { message = ex.Message });\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Token refresh failed");\r\n            return StatusCode(500, new { message = "An error occurred during token refresh" });\r\n        }\r\n    }\r\n\r\n    [HttpPost("revoke-token")]\r\n    [Authorize]\r\n    public async Task<IActionResult> RevokeToken([FromBody] RevokeTokenRequest request)\r\n    {\r\n        try\r\n        {\r\n            await _jwtService.Revo\r\n\r\n------------\r\nif needed please start from after  stable sub section. You were in the middle of Sample Implementation of 50. JWT Tokens\r\n- if you think you will run out of response limit. pause at a stable point and print --continue-- and keep the state  in mind , so when I ask you to continue, you can continue the task from that checkpoint\r\n\r\nGitHub Copilot: I\'ll continue from where the JWT Tokens sample implementation left off, completing the controller and then moving to the remaining sections.\r\n\r\n## 50. JWT Tokens (continued)\r\n\r\n```csharp\r\n    [HttpPost("revoke-token")]\r\n    [Authorize]\r\n    public async Task<IActionResult> RevokeToken([FromBody] RevokeTokenRequest request)\r\n    {\r\n        try\r\n        {\r\n            await _jwtService.RevokeTokenAsync(request.RefreshToken);\r\n            return Ok(new { message = "Token revoked successfully" });\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Token revocation failed");\r\n            return BadRequest(new { message = "Token revocation failed" });\r\n        }\r\n    }\r\n\r\n    private string GetIpAddress()\r\n    {\r\n        return HttpContext.Connection.RemoteIpAddress?.MapToIPv4().ToString() ?? "Unknown";\r\n    }\r\n}\r\n\r\n// Models/DTOs\r\npublic class LoginRequest\r\n{\r\n    public string Email { get; set; } = string.Empty;\r\n    public string Password { get; set; } = string.Empty;\r\n}\r\n\r\npublic class AuthResponse\r\n{\r\n    public string AccessToken { get; set; } = string.Empty;\r\n    public string RefreshToken { get; set; } = string.Empty;\r\n    public DateTime ExpiresAt { get; set; }\r\n    public UserDto User { get; set; } = null!;\r\n}\r\n\r\npublic class RefreshTokenRequest\r\n{\r\n    public string RefreshToken { get; set; } = string.Empty;\r\n}\r\n\r\npublic class RevokeTokenRequest\r\n{\r\n    public string RefreshToken { get; set; } = string.Empty;\r\n}\r\n\r\n// JWT Configuration in appsettings.json\r\n{\r\n  "JwtSettings": {\r\n    "SecretKey": "your-super-secret-key-that-is-at-least-256-bits-long",\r\n    "Issuer": "HotelManagement.Api",\r\n    "Audience": "HotelManagement.Client",\r\n    "ExpirationInMinutes": 15,\r\n    "RefreshTokenExpirationInDays": 7\r\n  }\r\n}\r\n\r\n// Program.cs configuration\r\nbuilder.Services.Configure<JwtSettings>(builder.Configuration.GetSection("JwtSettings"));\r\n\r\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n    .AddJwtBearer(options =>\r\n    {\r\n        var jwtSettings = builder.Configuration.GetSection("JwtSettings").Get<JwtSettings>();\r\n        options.TokenValidationParameters = new TokenValidationParameters\r\n        {\r\n            ValidateIssuerSigningKey = true,\r\n            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings.SecretKey)),\r\n            ValidateIssuer = true,\r\n            ValidIssuer = jwtSettings.Issuer,\r\n            ValidateAudience = true,\r\n            ValidAudience = jwtSettings.Audience,\r\n            ValidateLifetime = true,\r\n            ClockSkew = TimeSpan.Zero\r\n        };\r\n    });\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"NuGet Packages Required:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />\r\n<PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="7.0.3" />\n'})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);