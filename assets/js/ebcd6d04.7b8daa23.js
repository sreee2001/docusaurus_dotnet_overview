"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[2789],{4041:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Topics/DataAccessAndPersistence/UnitOfWorkPattern","title":"Unit of Work","description":"The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates writing out changes and resolving concurrency problems. It ensures that multiple repository operations are treated as a single transaction.","source":"@site/docs/Topics/04_DataAccessAndPersistence/22_UnitOfWorkPattern.md","sourceDirName":"Topics/04_DataAccessAndPersistence","slug":"/Topics/DataAccessAndPersistence/unit_of_work","permalink":"/docusaurus_dotnet_overview/docs/Topics/DataAccessAndPersistence/unit_of_work","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"dotnet","permalink":"/docusaurus_dotnet_overview/docs/tags/dotnet"},{"inline":true,"label":"database","permalink":"/docusaurus_dotnet_overview/docs/tags/database"},{"inline":true,"label":"uow","permalink":"/docusaurus_dotnet_overview/docs/tags/uow"},{"inline":true,"label":"unit_of_work","permalink":"/docusaurus_dotnet_overview/docs/tags/unit-of-work"},{"inline":true,"label":"patterns","permalink":"/docusaurus_dotnet_overview/docs/tags/patterns"},{"inline":true,"label":"design_pattern","permalink":"/docusaurus_dotnet_overview/docs/tags/design-pattern"},{"inline":true,"label":"architecture","permalink":"/docusaurus_dotnet_overview/docs/tags/architecture"}],"version":"current","sidebarPosition":22,"frontMatter":{"slug":"unit_of_work","title":"Unit of Work","tags":["dotnet","database","uow","unit_of_work","patterns","design_pattern","architecture"]},"sidebar":"tutorialSidebar","previous":{"title":"Repository Pattern","permalink":"/docusaurus_dotnet_overview/docs/Topics/DataAccessAndPersistence/repository_pattern"},"next":{"title":"Unit Testing","permalink":"/docusaurus_dotnet_overview/docs/Topics/Testing/unit_testing"}}');var i=t(4848),s=t(8453);const o={slug:"unit_of_work",title:"Unit of Work",tags:["dotnet","database","uow","unit_of_work","patterns","design_pattern","architecture"]},a="Unit of Work",c={},l=[{value:"Official Definition",id:"official-definition",level:2},{value:"Usage",id:"usage",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Use Unit of Work when:",id:"use-unit-of-work-when",level:3},{value:"Don&#39;t use Unit of Work when:",id:"dont-use-unit-of-work-when",level:3},{value:"Market Alternatives and Market Adoption",id:"market-alternatives-and-market-adoption",level:2},{value:"Pros and Cons",id:"pros-and-cons",level:2},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Sample Usage",id:"sample-usage",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"unit-of-work",children:"Unit of Work"})}),"\n",(0,i.jsx)(e.p,{children:"The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates writing out changes and resolving concurrency problems. It ensures that multiple repository operations are treated as a single transaction."}),"\n",(0,i.jsx)(e.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,i.jsx)(e.p,{children:"The Unit of Work pattern maintains a list of objects affected by a business transaction and coordinates writing out changes. It tracks changes to objects during a business transaction and coordinates writing out changes as a single operation."}),"\n",(0,i.jsx)(e.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(e.p,{children:"Implement by creating a class that manages multiple repositories and provides a single commit method. Often used with Entity Framework's DbContext, which already implements the Unit of Work pattern internally."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"public interface IUnitOfWork : IDisposable\r\n{\r\n    Task<int> SaveChangesAsync();\r\n    Task BeginTransactionAsync();\r\n    Task CommitTransactionAsync();\r\n    Task RollbackTransactionAsync();\r\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Coordinating multiple repository operations in a single transaction"}),"\n",(0,i.jsx)(e.li,{children:"Ensuring data consistency across multiple entities"}),"\n",(0,i.jsx)(e.li,{children:"Implementing complex business operations that span multiple aggregates"}),"\n",(0,i.jsx)(e.li,{children:"Managing database transactions at the application level"}),"\n",(0,i.jsx)(e.li,{children:"Batch processing multiple changes efficiently"}),"\n",(0,i.jsx)(e.li,{children:"Implementing saga patterns in microservices"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,i.jsx)(e.h3,{id:"use-unit-of-work-when",children:"Use Unit of Work when:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Operations span multiple repositories or entities"}),"\n",(0,i.jsx)(e.li,{children:"Need explicit transaction control"}),"\n",(0,i.jsx)(e.li,{children:"Implementing complex business workflows"}),"\n",(0,i.jsx)(e.li,{children:"Coordinating changes across multiple bounded contexts"}),"\n",(0,i.jsx)(e.li,{children:"Building systems with strict consistency requirements"}),"\n",(0,i.jsx)(e.li,{children:"Need to optimize database round trips"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"dont-use-unit-of-work-when",children:"Don't use Unit of Work when:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Using Entity Framework DbContext directly (it's already a UoW)"}),"\n",(0,i.jsx)(e.li,{children:"Operations are simple and single-entity focused"}),"\n",(0,i.jsx)(e.li,{children:"Over-engineering simple CRUD operations"}),"\n",(0,i.jsx)(e.li,{children:"Team lacks understanding of transaction concepts"}),"\n",(0,i.jsx)(e.li,{children:"Performance overhead is not justified"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"market-alternatives-and-market-adoption",children:"Market Alternatives and Market Adoption"}),"\n",(0,i.jsx)(e.p,{children:"Entity Framework Core's DbContext implements the Unit of Work pattern internally. Alternatives include manual transaction management, distributed transaction coordinators, and message-based eventual consistency patterns. Many modern applications use DbContext directly rather than implementing additional UoW abstractions."}),"\n",(0,i.jsx)(e.h2,{id:"pros-and-cons",children:"Pros and Cons"}),"\n",(0,i.jsx)(e.h3,{id:"pros",children:"Pros:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Ensures transactional consistency"}),"\n",(0,i.jsx)(e.li,{children:"Optimizes database round trips"}),"\n",(0,i.jsx)(e.li,{children:"Clear transaction boundaries"}),"\n",(0,i.jsx)(e.li,{children:"Supports complex business operations"}),"\n",(0,i.jsx)(e.li,{children:"Enables rollback of multiple changes"}),"\n",(0,i.jsx)(e.li,{children:"Coordinates multiple repositories"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"cons",children:"Cons:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Adds complexity to simple operations"}),"\n",(0,i.jsx)(e.li,{children:"Can create tight coupling between entities"}),"\n",(0,i.jsx)(e.li,{children:"Memory overhead for tracking changes"}),"\n",(0,i.jsx)(e.li,{children:"Potential for long-running transactions"}),"\n",(0,i.jsx)(e.li,{children:"May duplicate EF Core functionality"}),"\n",(0,i.jsx)(e.li,{children:"Requires careful lifecycle management"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"sample-usage",children:"Sample Usage"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// Package reference: Microsoft.EntityFrameworkCore\r\nusing Microsoft.EntityFrameworkCore;\r\nusing Microsoft.EntityFrameworkCore.Storage;\r\n\r\n// Domain models\r\npublic class Guest\r\n{\r\n    public int Id { get; set; }\r\n    public string FirstName { get; set; } = string.Empty;\r\n    public string LastName { get; set; } = string.Empty;\r\n    public string Email { get; set; } = string.Empty;\r\n}\r\n\r\npublic class Booking\r\n{\r\n    public int Id { get; set; }\r\n    public int GuestId { get; set; }\r\n    public int RoomId { get; set; }\r\n    public DateTime CheckInDate { get; set; }\r\n    public DateTime CheckOutDate { get; set; }\r\n    public decimal TotalAmount { get; set; }\r\n    public Guest Guest { get; set; } = null!;\r\n}\r\n\r\npublic class Payment\r\n{\r\n    public int Id { get; set; }\r\n    public int BookingId { get; set; }\r\n    public decimal Amount { get; set; }\r\n    public DateTime PaymentDate { get; set; }\r\n    public string PaymentMethod { get; set; } = string.Empty;\r\n    public Booking Booking { get; set; } = null!;\r\n}\r\n\r\n// Repository interfaces\r\npublic interface IGuestRepository\r\n{\r\n    Task<Guest> AddAsync(Guest guest);\r\n    Task<Guest?> GetByEmailAsync(string email);\r\n}\r\n\r\npublic interface IBookingRepository\r\n{\r\n    Task<Booking> AddAsync(Booking booking);\r\n    Task<Booking?> GetByIdAsync(int id);\r\n}\r\n\r\npublic interface IPaymentRepository\r\n{\r\n    Task<Payment> AddAsync(Payment payment);\r\n    Task<IEnumerable<Payment>> GetByBookingIdAsync(int bookingId);\r\n}\r\n\r\n// Unit of Work interface\r\npublic interface IUnitOfWork : IDisposable\r\n{\r\n    IGuestRepository Guests { get; }\r\n    IBookingRepository Bookings { get; }\r\n    IPaymentRepository Payments { get; }\r\n\r\n    Task<int> SaveChangesAsync();\r\n    Task BeginTransactionAsync();\r\n    Task CommitTransactionAsync();\r\n    Task RollbackTransactionAsync();\r\n}\r\n\r\n// DbContext\r\npublic class HotelDbContext : DbContext\r\n{\r\n    public HotelDbContext(DbContextOptions<HotelDbContext> options) : base(options) { }\r\n\r\n    public DbSet<Guest> Guests { get; set; }\r\n    public DbSet<Booking> Bookings { get; set; }\r\n    public DbSet<Payment> Payments { get; set; }\r\n}\r\n\r\n// Repository implementations\r\npublic class GuestRepository : IGuestRepository\r\n{\r\n    private readonly HotelDbContext _context;\r\n\r\n    public GuestRepository(HotelDbContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public async Task<Guest> AddAsync(Guest guest)\r\n    {\r\n        _context.Guests.Add(guest);\r\n        return guest;\r\n    }\r\n\r\n    public async Task<Guest?> GetByEmailAsync(string email)\r\n    {\r\n        return await _context.Guests.FirstOrDefaultAsync(g => g.Email == email);\r\n    }\r\n}\r\n\r\npublic class BookingRepository : IBookingRepository\r\n{\r\n    private readonly HotelDbContext _context;\r\n\r\n    public BookingRepository(HotelDbContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public async Task<Booking> AddAsync(Booking booking)\r\n    {\r\n        _context.Bookings.Add(booking);\r\n        return booking;\r\n    }\r\n\r\n    public async Task<Booking?> GetByIdAsync(int id)\r\n    {\r\n        return await _context.Bookings\r\n            .Include(b => b.Guest)\r\n            .FirstOrDefaultAsync(b => b.Id == id);\r\n    }\r\n}\r\n\r\npublic class PaymentRepository : IPaymentRepository\r\n{\r\n    private readonly HotelDbContext _context;\r\n\r\n    public PaymentRepository(HotelDbContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public async Task<Payment> AddAsync(Payment payment)\r\n    {\r\n        _context.Payments.Add(payment);\r\n        return payment;\r\n    }\r\n\r\n    public async Task<IEnumerable<Payment>> GetByBookingIdAsync(int bookingId)\r\n    {\r\n        return await _context.Payments\r\n            .Where(p => p.BookingId == bookingId)\r\n            .ToListAsync();\r\n    }\r\n}\r\n\r\n// Unit of Work implementation\r\npublic class UnitOfWork : IUnitOfWork\r\n{\r\n    private readonly HotelDbContext _context;\r\n    private IDbContextTransaction? _transaction;\r\n\r\n    public UnitOfWork(HotelDbContext context)\r\n    {\r\n        _context = context;\r\n        Guests = new GuestRepository(_context);\r\n        Bookings = new BookingRepository(_context);\r\n        Payments = new PaymentRepository(_context);\r\n    }\r\n\r\n    public IGuestRepository Guests { get; }\r\n    public IBookingRepository Bookings { get; }\r\n    public IPaymentRepository Payments { get; }\r\n\r\n    public async Task<int> SaveChangesAsync()\r\n    {\r\n        return await _context.SaveChangesAsync();\r\n    }\r\n\r\n    public async Task BeginTransactionAsync()\r\n    {\r\n        _transaction = await _context.Database.BeginTransactionAsync();\r\n    }\r\n\r\n    public async Task CommitTransactionAsync()\r\n    {\r\n        if (_transaction != null)\r\n        {\r\n            await _transaction.CommitAsync();\r\n            await _transaction.DisposeAsync();\r\n            _transaction = null;\r\n        }\r\n    }\r\n\r\n    public async Task RollbackTransactionAsync()\r\n    {\r\n        if (_transaction != null)\r\n        {\r\n            await _transaction.RollbackAsync();\r\n            await _transaction.DisposeAsync();\r\n            _transaction = null;\r\n        }\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        _transaction?.Dispose();\r\n        _context.Dispose();\r\n    }\r\n}\r\n\r\n// Business service using Unit of Work\r\npublic class BookingService\r\n{\r\n    private readonly IUnitOfWork _unitOfWork;\r\n\r\n    public BookingService(IUnitOfWork unitOfWork)\r\n    {\r\n        _unitOfWork = unitOfWork;\r\n    }\r\n\r\n    public async Task<Booking> CreateBookingWithPaymentAsync(\r\n        string guestEmail,\r\n        string firstName,\r\n        string lastName,\r\n        int roomId,\r\n        DateTime checkIn,\r\n        DateTime checkOut,\r\n        decimal totalAmount,\r\n        decimal paymentAmount,\r\n        string paymentMethod)\r\n    {\r\n        await _unitOfWork.BeginTransactionAsync();\r\n\r\n        try\r\n        {\r\n            // Find or create guest\r\n            var guest = await _unitOfWork.Guests.GetByEmailAsync(guestEmail);\r\n            if (guest == null)\r\n            {\r\n                guest = new Guest\r\n                {\r\n                    FirstName = firstName,\r\n                    LastName = lastName,\r\n                    Email = guestEmail\r\n                };\r\n                await _unitOfWork.Guests.AddAsync(guest);\r\n                await _unitOfWork.SaveChangesAsync(); // Save to get ID\r\n            }\r\n\r\n            // Create booking\r\n            var booking = new Booking\r\n            {\r\n                GuestId = guest.Id,\r\n                RoomId = roomId,\r\n                CheckInDate = checkIn,\r\n                CheckOutDate = checkOut,\r\n                TotalAmount = totalAmount\r\n            };\r\n\r\n            await _unitOfWork.Bookings.AddAsync(booking);\r\n            await _unitOfWork.SaveChangesAsync(); // Save to get booking ID\r\n\r\n            // Create payment\r\n            var payment = new Payment\r\n            {\r\n                BookingId = booking.Id,\r\n                Amount = paymentAmount,\r\n                PaymentDate = DateTime.UtcNow,\r\n                PaymentMethod = paymentMethod\r\n            };\r\n\r\n            await _unitOfWork.Payments.AddAsync(payment);\r\n            await _unitOfWork.SaveChangesAsync();\r\n\r\n            await _unitOfWork.CommitTransactionAsync();\r\n            return booking;\r\n        }\r\n        catch\r\n        {\r\n            await _unitOfWork.RollbackTransactionAsync();\r\n            throw;\r\n        }\r\n    }\r\n}\r\n\r\n// Dependency injection setup (Program.cs)\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddDbContext<HotelDbContext>(options =>\r\n    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));\r\n\r\nbuilder.Services.AddScoped<IUnitOfWork, UnitOfWork>();\r\nbuilder.Services.AddScoped<BookingService>();\r\n\r\nvar app = builder.Build();\r\n\r\n// Usage example\r\npublic class BookingsController : ControllerBase\r\n{\r\n    private readonly BookingService _bookingService;\r\n\r\n    public BookingsController(BookingService bookingService)\r\n    {\r\n        _bookingService = bookingService;\r\n    }\r\n\r\n    [HttpPost("with-payment")]\r\n    public async Task<ActionResult<Booking>> CreateBookingWithPayment([FromBody] CreateBookingWithPaymentRequest request)\r\n    {\r\n        try\r\n        {\r\n            var booking = await _bookingService.CreateBookingWithPaymentAsync(\r\n                request.GuestEmail,\r\n                request.FirstName,\r\n                request.LastName,\r\n                request.RoomId,\r\n                request.CheckIn,\r\n                request.CheckOut,\r\n                request.TotalAmount,\r\n                request.PaymentAmount,\r\n                request.PaymentMethod);\r\n\r\n            return CreatedAtAction(nameof(GetBooking), new { id = booking.Id }, booking);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            return BadRequest(ex.Message);\r\n        }\r\n    }\r\n}\r\n\r\npublic class CreateBookingWithPaymentRequest\r\n{\r\n    public string GuestEmail { get; set; } = string.Empty;\r\n    public string FirstName { get; set; } = string.Empty;\r\n    public string LastName { get; set; } = string.Empty;\r\n    public int RoomId { get; set; }\r\n    public DateTime CheckIn { get; set; }\r\n    public DateTime CheckOut { get; set; }\r\n    public decimal TotalAmount { get; set; }\r\n    public decimal PaymentAmount { get; set; }\r\n    public string PaymentMethod { get; set; } = string.Empty;\r\n}\n'})})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function o(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);