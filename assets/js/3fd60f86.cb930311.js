"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[6662],{3337:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"Topics/Microservices/ServiceDiscovery","title":"ServiceDiscovery","description":"46. Service Discovery","source":"@site/docs/Topics/10_Microservices/46_ServiceDiscovery.md","sourceDirName":"Topics/10_Microservices","slug":"/Topics/Microservices/ServiceDiscovery","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/ServiceDiscovery","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":46,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"APIGateway","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/APIGateway"},"next":{"title":"CircuitBreakerPatern","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/CircuitBreakerPatern"}}');var s=n(4848),t=n(8453);const c={},o=void 0,l={},a=[{value:"46. Service Discovery",id:"46-service-discovery",level:2},{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition",id:"official-definition",level:2},{value:"Setup/Usage with .NET 8+ Code",id:"setupusage-with-net-8-code",level:2},{value:"Use Cases",id:"use-cases",level:3},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Market Alternatives &amp; Pros/Cons",id:"market-alternatives--proscons",level:3},{value:"Alternatives:",id:"alternatives",level:3},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Complete Runnable Sample",id:"complete-runnable-sample",level:3}];function v(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h2,{id:"46-service-discovery",children:"46. Service Discovery"}),"\n",(0,s.jsx)(r.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,s.jsx)(r.p,{children:"Service Discovery is a mechanism that allows services in a distributed system to automatically locate and communicate with each other without hard-coded network locations. It provides dynamic registration and discovery of service instances, enabling resilient communication in microservices architectures where services can scale up/down and move between hosts."}),"\n",(0,s.jsx)(r.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,s.jsx)(r.p,{children:"Service Discovery is a key component of most distributed systems and service-oriented architectures. The service instances have dynamically assigned network locations. Moreover, the set of service instances changes dynamically because of autoscaling, failures, and upgrades."}),"\n",(0,s.jsx)(r.h2,{id:"setupusage-with-net-8-code",children:"Setup/Usage with .NET 8+ Code"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Consul Service Discovery Implementation:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Install Consul packages\r\ndotnet add package Consul\r\ndotnet add package Microsoft.Extensions.Hosting\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Service Registration:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-csharp",children:'// Services/ConsulServiceRegistry.cs\r\nusing Consul;\r\n\r\npublic interface IServiceRegistry\r\n{\r\n    Task RegisterServiceAsync(ServiceRegistration registration);\r\n    Task DeregisterServiceAsync(string serviceId);\r\n    Task<IEnumerable<ServiceInstance>> DiscoverServicesAsync(string serviceName);\r\n}\r\n\r\npublic class ConsulServiceRegistry : IServiceRegistry, IDisposable\r\n{\r\n    private readonly IConsulClient _consulClient;\r\n    private readonly ILogger<ConsulServiceRegistry> _logger;\r\n\r\n    public ConsulServiceRegistry(IConsulClient consulClient, ILogger<ConsulServiceRegistry> logger)\r\n    {\r\n        _consulClient = consulClient;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task RegisterServiceAsync(ServiceRegistration registration)\r\n    {\r\n        var consulRegistration = new AgentServiceRegistration\r\n        {\r\n            ID = registration.ServiceId,\r\n            Name = registration.ServiceName,\r\n            Address = registration.Address,\r\n            Port = registration.Port,\r\n            Tags = registration.Tags.ToArray(),\r\n            Check = new AgentServiceCheck\r\n            {\r\n                HTTP = $"http://{registration.Address}:{registration.Port}/health",\r\n                Interval = TimeSpan.FromSeconds(30),\r\n                Timeout = TimeSpan.FromSeconds(5),\r\n                DeregisterCriticalServiceAfter = TimeSpan.FromMinutes(1)\r\n            }\r\n        };\r\n\r\n        await _consulClient.Agent.ServiceRegister(consulRegistration);\r\n        _logger.LogInformation("Service {ServiceName} registered with ID {ServiceId}",\r\n            registration.ServiceName, registration.ServiceId);\r\n    }\r\n\r\n    public async Task DeregisterServiceAsync(string serviceId)\r\n    {\r\n        await _consulClient.Agent.ServiceDeregister(serviceId);\r\n        _logger.LogInformation("Service {ServiceId} deregistered", serviceId);\r\n    }\r\n\r\n    public async Task<IEnumerable<ServiceInstance>> DiscoverServicesAsync(string serviceName)\r\n    {\r\n        var services = await _consulClient.Health.Service(serviceName, "", true);\r\n\r\n        return services.Response.Select(service => new ServiceInstance\r\n        {\r\n            ServiceId = service.Service.ID,\r\n            ServiceName = service.Service.Service,\r\n            Address = service.Service.Address,\r\n            Port = service.Service.Port,\r\n            Tags = service.Service.Tags?.ToList() ?? new List<string>(),\r\n            IsHealthy = service.Checks.All(check => check.Status == HealthStatus.Passing)\r\n        });\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        _consulClient?.Dispose();\r\n    }\r\n}\r\n\r\n// Models/ServiceRegistration.cs\r\npublic class ServiceRegistration\r\n{\r\n    public string ServiceId { get; set; } = string.Empty;\r\n    public string ServiceName { get; set; } = string.Empty;\r\n    public string Address { get; set; } = string.Empty;\r\n    public int Port { get; set; }\r\n    public List<string> Tags { get; set; } = new();\r\n}\r\n\r\npublic class ServiceInstance\r\n{\r\n    public string ServiceId { get; set; } = string.Empty;\r\n    public string ServiceName { get; set; } = string.Empty;\r\n    public string Address { get; set; } = string.Empty;\r\n    public int Port { get; set; }\r\n    public List<string> Tags { get; set; } = new();\r\n    public bool IsHealthy { get; set; }\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Program.cs Integration:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-csharp",children:'// Program.cs\r\nusing Consul;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add Consul client\r\nbuilder.Services.AddSingleton<IConsulClient>(provider =>\r\n{\r\n    var consulConfig = new ConsulClientConfiguration\r\n    {\r\n        Address = new Uri(builder.Configuration["Consul:Address"] ?? "http://localhost:8500")\r\n    };\r\n    return new ConsulClient(consulConfig);\r\n});\r\n\r\n// Add service registry\r\nbuilder.Services.AddSingleton<IServiceRegistry, ConsulServiceRegistry>();\r\nbuilder.Services.AddHostedService<ServiceRegistrationService>();\r\n\r\n// Add HTTP client factory with service discovery\r\nbuilder.Services.AddHttpClient<IBookingServiceClient, BookingServiceClient>();\r\nbuilder.Services.AddSingleton<IServiceDiscoveryHttpClientFactory, ServiceDiscoveryHttpClientFactory>();\r\n\r\nvar app = builder.Build();\r\n\r\n// Configure pipeline\r\napp.MapControllers();\r\napp.MapHealthChecks("/health");\r\n\r\napp.Run();\r\n\r\n// Services/ServiceRegistrationService.cs\r\npublic class ServiceRegistrationService : BackgroundService\r\n{\r\n    private readonly IServiceRegistry _serviceRegistry;\r\n    private readonly IConfiguration _configuration;\r\n    private readonly ILogger<ServiceRegistrationService> _logger;\r\n    private string? _serviceId;\r\n\r\n    public ServiceRegistrationService(\r\n        IServiceRegistry serviceRegistry,\r\n        IConfiguration configuration,\r\n        ILogger<ServiceRegistrationService> logger)\r\n    {\r\n        _serviceRegistry = serviceRegistry;\r\n        _configuration = configuration;\r\n        _logger = logger;\r\n    }\r\n\r\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\r\n    {\r\n        await RegisterService();\r\n\r\n        // Keep the service alive\r\n        await Task.Delay(Timeout.Infinite, stoppingToken);\r\n    }\r\n\r\n    public override async Task StopAsync(CancellationToken cancellationToken)\r\n    {\r\n        if (!string.IsNullOrEmpty(_serviceId))\r\n        {\r\n            await _serviceRegistry.DeregisterServiceAsync(_serviceId);\r\n        }\r\n        await base.StopAsync(cancellationToken);\r\n    }\r\n\r\n    private async Task RegisterService()\r\n    {\r\n        try\r\n        {\r\n            var serviceName = _configuration["Service:Name"] ?? "unknown-service";\r\n            var serviceAddress = _configuration["Service:Address"] ?? "localhost";\r\n            var servicePort = int.Parse(_configuration["Service:Port"] ?? "8080");\r\n\r\n            _serviceId = $"{serviceName}-{Environment.MachineName}-{Guid.NewGuid():N}";\r\n\r\n            var registration = new ServiceRegistration\r\n            {\r\n                ServiceId = _serviceId,\r\n                ServiceName = serviceName,\r\n                Address = serviceAddress,\r\n                Port = servicePort,\r\n                Tags = new List<string> { "v1", Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Unknown" }\r\n            };\r\n\r\n            await _serviceRegistry.RegisterServiceAsync(registration);\r\n            _logger.LogInformation("Service registered successfully");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Failed to register service");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Service Discovery HTTP Client:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-csharp",children:'// Services/ServiceDiscoveryHttpClientFactory.cs\r\npublic interface IServiceDiscoveryHttpClientFactory\r\n{\r\n    Task<HttpClient> CreateClientAsync(string serviceName);\r\n}\r\n\r\npublic class ServiceDiscoveryHttpClientFactory : IServiceDiscoveryHttpClientFactory\r\n{\r\n    private readonly IServiceRegistry _serviceRegistry;\r\n    private readonly IHttpClientFactory _httpClientFactory;\r\n    private readonly ILogger<ServiceDiscoveryHttpClientFactory> _logger;\r\n    private readonly Dictionary<string, DateTime> _lastDiscovery = new();\r\n    private readonly Dictionary<string, List<ServiceInstance>> _serviceCache = new();\r\n    private readonly object _lock = new();\r\n\r\n    public ServiceDiscoveryHttpClientFactory(\r\n        IServiceRegistry serviceRegistry,\r\n        IHttpClientFactory httpClientFactory,\r\n        ILogger<ServiceDiscoveryHttpClientFactory> logger)\r\n    {\r\n        _serviceRegistry = serviceRegistry;\r\n        _httpClientFactory = httpClientFactory;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<HttpClient> CreateClientAsync(string serviceName)\r\n    {\r\n        var serviceInstance = await GetServiceInstanceAsync(serviceName);\r\n\r\n        var client = _httpClientFactory.CreateClient();\r\n        client.BaseAddress = new Uri($"http://{serviceInstance.Address}:{serviceInstance.Port}");\r\n        client.DefaultRequestHeaders.Add("X-Service-Discovery", "Consul");\r\n\r\n        return client;\r\n    }\r\n\r\n    private async Task<ServiceInstance> GetServiceInstanceAsync(string serviceName)\r\n    {\r\n        List<ServiceInstance> instances;\r\n\r\n        lock (_lock)\r\n        {\r\n            if (_serviceCache.TryGetValue(serviceName, out instances) &&\r\n                _lastDiscovery.TryGetValue(serviceName, out var lastDiscovery) &&\r\n                DateTime.UtcNow - lastDiscovery < TimeSpan.FromMinutes(1))\r\n            {\r\n                // Use cached instances if they\'re recent\r\n            }\r\n            else\r\n            {\r\n                instances = null;\r\n            }\r\n        }\r\n\r\n        if (instances == null)\r\n        {\r\n            instances = (await _serviceRegistry.DiscoverServicesAsync(serviceName))\r\n                .Where(s => s.IsHealthy)\r\n                .ToList();\r\n\r\n            lock (_lock)\r\n            {\r\n                _serviceCache[serviceName] = instances;\r\n                _lastDiscovery[serviceName] = DateTime.UtcNow;\r\n            }\r\n        }\r\n\r\n        if (!instances.Any())\r\n        {\r\n            throw new InvalidOperationException($"No healthy instances found for service: {serviceName}");\r\n        }\r\n\r\n        // Simple round-robin load balancing\r\n        var selectedInstance = instances[Random.Shared.Next(instances.Count)];\r\n\r\n        _logger.LogDebug("Selected instance {ServiceId} for service {ServiceName}",\r\n            selectedInstance.ServiceId, serviceName);\r\n\r\n        return selectedInstance;\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Microservices Communication"}),": Dynamic service-to-service communication"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Load Balancing"}),": Distribute requests across multiple service instances"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Auto-scaling"}),": Automatically discover new instances as they come online"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Fault Tolerance"}),": Remove unhealthy instances from service discovery"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Blue-Green Deployments"}),": Route traffic between different service versions"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Multi-Environment Support"}),": Different service configurations per environment"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Use Service Discovery when:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Building microservices with multiple instances"}),"\n",(0,s.jsx)(r.li,{children:"Services need to communicate dynamically"}),"\n",(0,s.jsx)(r.li,{children:"Using container orchestration (Docker, Kubernetes)"}),"\n",(0,s.jsx)(r.li,{children:"Implementing auto-scaling"}),"\n",(0,s.jsx)(r.li,{children:"Need health-based routing"}),"\n",(0,s.jsx)(r.li,{children:"Working with multiple environments"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Consider alternatives when:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Simple monolithic applications"}),"\n",(0,s.jsx)(r.li,{children:"Fixed, well-known service endpoints"}),"\n",(0,s.jsx)(r.li,{children:"Small number of services with static configuration"}),"\n",(0,s.jsx)(r.li,{children:"Network policies restrict dynamic discovery"}),"\n",(0,s.jsx)(r.li,{children:"Complexity outweighs benefits"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"market-alternatives--proscons",children:"Market Alternatives & Pros/Cons"}),"\n",(0,s.jsx)(r.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Kubernetes DNS"}),": Built-in service discovery for Kubernetes"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Netflix Eureka"}),": Service registry for resilient mid-tier load balancing"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"etcd"}),": Distributed key-value store for service discovery"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Apache Zookeeper"}),": Centralized service for configuration and naming"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"AWS Cloud Map"}),": Managed service discovery for AWS"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Azure Service Fabric"}),": Microsoft's service discovery solution"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"pros",children:"Pros:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Dynamic service location"}),"\n",(0,s.jsx)(r.li,{children:"Automatic health checking"}),"\n",(0,s.jsx)(r.li,{children:"Load balancing capabilities"}),"\n",(0,s.jsx)(r.li,{children:"Multi-datacenter support"}),"\n",(0,s.jsx)(r.li,{children:"Rich querying and filtering"}),"\n",(0,s.jsx)(r.li,{children:"Battle-tested in production"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"cons",children:"Cons:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Additional infrastructure dependency"}),"\n",(0,s.jsx)(r.li,{children:"Potential single point of failure"}),"\n",(0,s.jsx)(r.li,{children:"Network latency for discovery calls"}),"\n",(0,s.jsx)(r.li,{children:"Complexity in service registration/deregistration"}),"\n",(0,s.jsx)(r.li,{children:"Consistency challenges in distributed scenarios"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"complete-runnable-sample",children:"Complete Runnable Sample"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Complete Service Discovery Setup:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-yaml",children:'# docker-compose.yml\r\nversion: "3.8"\r\nservices:\r\n  consul:\r\n    image: consul:1.15\r\n    ports:\r\n      - "8500:8500"\r\n    command: >\r\n      consul agent -dev -client=0.0.0.0 -ui\r\n    environment:\r\n      - CONSUL_BIND_INTERFACE=eth0\r\n    networks:\r\n      - hotel-network\r\n\r\n  booking-service:\r\n    build: ./BookingService\r\n    environment:\r\n      - ASPNETCORE_ENVIRONMENT=Development\r\n      - Consul__Address=http://consul:8500\r\n      - Service__Name=booking-service\r\n      - Service__Address=booking-service\r\n      - Service__Port=8080\r\n    depends_on:\r\n      - consul\r\n    networks:\r\n      - hotel-network\r\n    deploy:\r\n      replicas: 2\r\n\r\n  room-service:\r\n    build: ./RoomService\r\n    environment:\r\n      - ASPNETCORE_ENVIRONMENT=Development\r\n      - Consul__Address=http://consul:8500\r\n      - Service__Name=room-service\r\n      - Service__Address=room-service\r\n      - Service__Port=8080\r\n    depends_on:\r\n      - consul\r\n    networks:\r\n      - hotel-network\r\n    deploy:\r\n      replicas: 3\r\n\r\nnetworks:\r\n  hotel-network:\r\n    driver: bridge\n'})})]})}function d(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(v,{...e})}):v(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>c,x:()=>o});var i=n(6540);const s={},t=i.createContext(s);function c(e){const r=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);