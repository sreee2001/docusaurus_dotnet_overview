"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[8433],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},9136:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Topics/DevOps_and_CI_CD/HealthChecks","title":"HealthChecks","description":"43. Health Checks","source":"@site/docs/Topics/09_DevOps_and_CI_CD/43_HealthChecks.md","sourceDirName":"Topics/09_DevOps_and_CI_CD","slug":"/Topics/DevOps_and_CI_CD/HealthChecks","permalink":"/docusaurus_dotnet_overview/docs/Topics/DevOps_and_CI_CD/HealthChecks","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":43,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Application Insights (Observability + Instrumentation)","permalink":"/docusaurus_dotnet_overview/docs/Topics/DevOps_and_CI_CD/application_insights"},"next":{"title":"MicroservicesArchitecture","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/MicroservicesArchitecture"}}');var a=r(4848),i=r(8453);const s={},o=void 0,l={},c=[{value:"43. Health Checks",id:"43-health-checks",level:2},{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition",id:"official-definition",level:2},{value:"Setup/Usage with .NET 8+ Code",id:"setupusage-with-net-8-code",level:2},{value:"Use Cases",id:"use-cases",level:3},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Market Alternatives &amp; Pros/Cons",id:"market-alternatives--proscons",level:3},{value:"Alternatives:",id:"alternatives",level:3},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Complete Runnable Sample",id:"complete-runnable-sample",level:3}];function h(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"43-health-checks",children:"43. Health Checks"}),"\n",(0,a.jsx)(n.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,a.jsx)(n.p,{children:"Health Checks in .NET provide a systematic way to monitor the health and availability of an application and its dependencies. They offer HTTP endpoints that can be called by load balancers, monitoring systems, and orchestrators to determine if an application instance should receive traffic or needs to be restarted."}),"\n",(0,a.jsx)(n.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,a.jsx)(n.p,{children:"Health Checks are diagnostic checks that can be performed on an application to determine its health status. They provide a consistent way to expose health information about an application and its dependencies, enabling monitoring systems to make informed decisions about traffic routing and instance management."}),"\n",(0,a.jsx)(n.h2,{id:"setupusage-with-net-8-code",children:"Setup/Usage with .NET 8+ Code"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Basic Health Checks Setup:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Program.cs\r\nusing Microsoft.Extensions.Diagnostics.HealthChecks;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add basic health checks\r\nbuilder.Services.AddHealthChecks()\r\n    .AddCheck("self", () => HealthCheckResult.Healthy("Application is running"))\r\n    .AddCheck<DatabaseHealthCheck>("database")\r\n    .AddCheck<RedisHealthCheck>("redis")\r\n    .AddCheck<ExternalApiHealthCheck>("external-api");\r\n\r\n// Add health checks UI (optional)\r\nbuilder.Services.AddHealthChecksUI(options =>\r\n{\r\n    options.SetEvaluationTimeInSeconds(30);\r\n    options.MaximumHistoryEntriesPerEndpoint(50);\r\n    options.AddHealthCheckEndpoint("Hotel Management API", "/health");\r\n}).AddInMemoryStorage();\r\n\r\nvar app = builder.Build();\r\n\r\n// Configure health check endpoints\r\napp.MapHealthChecks("/health", new HealthCheckOptions\r\n{\r\n    ResponseWriter = WriteHealthCheckResponse\r\n});\r\n\r\napp.MapHealthChecks("/health/ready", new HealthCheckOptions\r\n{\r\n    Predicate = check => check.Tags.Contains("ready"),\r\n    ResponseWriter = WriteHealthCheckResponse\r\n});\r\n\r\napp.MapHealthChecks("/health/live", new HealthCheckOptions\r\n{\r\n    Predicate = _ => false, // Only checks with no dependencies\r\n    ResponseWriter = WriteHealthCheckResponse\r\n});\r\n\r\n// Add health checks UI\r\napp.MapHealthChecksUI(options =>\r\n{\r\n    options.UIPath = "/health-ui";\r\n    options.ApiPath = "/health-api";\r\n});\r\n\r\napp.Run();\r\n\r\n// Custom response writer\r\nstatic async Task WriteHealthCheckResponse(HttpContext context, HealthReport report)\r\n{\r\n    context.Response.ContentType = "application/json";\r\n\r\n    var result = new\r\n    {\r\n        status = report.Status.ToString(),\r\n        totalDuration = report.TotalDuration.TotalMilliseconds,\r\n        checks = report.Entries.Select(entry => new\r\n        {\r\n            name = entry.Key,\r\n            status = entry.Value.Status.ToString(),\r\n            duration = entry.Value.Duration.TotalMilliseconds,\r\n            description = entry.Value.Description,\r\n            data = entry.Value.Data,\r\n            exception = entry.Value.Exception?.Message,\r\n            tags = entry.Value.Tags\r\n        })\r\n    };\r\n\r\n    await context.Response.WriteAsync(JsonSerializer.Serialize(result, new JsonSerializerOptions\r\n    {\r\n        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\r\n        WriteIndented = true\r\n    }));\r\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Custom Health Checks Implementation:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// HealthChecks/DatabaseHealthCheck.cs\r\npublic class DatabaseHealthCheck : IHealthCheck\r\n{\r\n    private readonly IConfiguration _configuration;\r\n    private readonly ILogger<DatabaseHealthCheck> _logger;\r\n\r\n    public DatabaseHealthCheck(IConfiguration configuration, ILogger<DatabaseHealthCheck> logger)\r\n    {\r\n        _configuration = configuration;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        try\r\n        {\r\n            var connectionString = _configuration.GetConnectionString("DefaultConnection");\r\n\r\n            using var connection = new SqlConnection(connectionString);\r\n            await connection.OpenAsync(cancellationToken);\r\n\r\n            using var command = connection.CreateCommand();\r\n            command.CommandText = "SELECT 1";\r\n            command.CommandTimeout = 5; // 5 second timeout\r\n\r\n            var result = await command.ExecuteScalarAsync(cancellationToken);\r\n\r\n            var data = new Dictionary<string, object>\r\n            {\r\n                ["server"] = connection.DataSource,\r\n                ["database"] = connection.Database,\r\n                ["connection_time"] = DateTime.UtcNow\r\n            };\r\n\r\n            return result?.ToString() == "1"\r\n                ? HealthCheckResult.Healthy("Database connection successful", data)\r\n                : HealthCheckResult.Unhealthy("Database query failed", null, data);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Database health check failed");\r\n\r\n            return HealthCheckResult.Unhealthy("Database connection failed", ex, new Dictionary<string, object>\r\n            {\r\n                ["error"] = ex.Message,\r\n                ["check_time"] = DateTime.UtcNow\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n// HealthChecks/RedisHealthCheck.cs\r\npublic class RedisHealthCheck : IHealthCheck\r\n{\r\n    private readonly IConnectionMultiplexer _connectionMultiplexer;\r\n    private readonly ILogger<RedisHealthCheck> _logger;\r\n\r\n    public RedisHealthCheck(IConnectionMultiplexer connectionMultiplexer, ILogger<RedisHealthCheck> logger)\r\n    {\r\n        _connectionMultiplexer = connectionMultiplexer;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        try\r\n        {\r\n            var database = _connectionMultiplexer.GetDatabase();\r\n            var key = $"health_check_{Guid.NewGuid()}";\r\n            var value = "ping";\r\n\r\n            // Test write\r\n            await database.StringSetAsync(key, value, TimeSpan.FromSeconds(30));\r\n\r\n            // Test read\r\n            var retrievedValue = await database.StringGetAsync(key);\r\n\r\n            // Clean up\r\n            await database.KeyDeleteAsync(key);\r\n\r\n            var data = new Dictionary<string, object>\r\n            {\r\n                ["server"] = _connectionMultiplexer.Configuration,\r\n                ["is_connected"] = _connectionMultiplexer.IsConnected,\r\n                ["check_time"] = DateTime.UtcNow\r\n            };\r\n\r\n            return retrievedValue == value\r\n                ? HealthCheckResult.Healthy("Redis connection successful", data)\r\n                : HealthCheckResult.Unhealthy("Redis read/write test failed", null, data);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Redis health check failed");\r\n\r\n            return HealthCheckResult.Unhealthy("Redis connection failed", ex, new Dictionary<string, object>\r\n            {\r\n                ["error"] = ex.Message,\r\n                ["check_time"] = DateTime.UtcNow\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n// HealthChecks/ExternalApiHealthCheck.cs\r\npublic class ExternalApiHealthCheck : IHealthCheck\r\n{\r\n    private readonly HttpClient _httpClient;\r\n    private readonly IConfiguration _configuration;\r\n    private readonly ILogger<ExternalApiHealthCheck> _logger;\r\n\r\n    public ExternalApiHealthCheck(HttpClient httpClient, IConfiguration configuration, ILogger<ExternalApiHealthCheck> logger)\r\n    {\r\n        _httpClient = httpClient;\r\n        _configuration = configuration;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        try\r\n        {\r\n            var apiUrl = _configuration["ExternalApi:BaseUrl"];\r\n            var healthEndpoint = $"{apiUrl}/health";\r\n\r\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\r\n            cts.CancelAfter(TimeSpan.FromSeconds(10)); // 10 second timeout\r\n\r\n            var response = await _httpClient.GetAsync(healthEndpoint, cts.Token);\r\n            var responseTime = DateTime.UtcNow;\r\n\r\n            var data = new Dictionary<string, object>\r\n            {\r\n                ["url"] = healthEndpoint,\r\n                ["status_code"] = (int)response.StatusCode,\r\n                ["response_time"] = responseTime,\r\n                ["is_success"] = response.IsSuccessStatusCode\r\n            };\r\n\r\n            if (response.IsSuccessStatusCode)\r\n            {\r\n                var content = await response.Content.ReadAsStringAsync(cancellationToken);\r\n                data["response_content"] = content.Length > 200 ? content[..200] + "..." : content;\r\n\r\n                return HealthCheckResult.Healthy($"External API is healthy (Status: {response.StatusCode})", data);\r\n            }\r\n            else\r\n            {\r\n                return HealthCheckResult.Degraded($"External API returned {response.StatusCode}", null, data);\r\n            }\r\n        }\r\n        catch (TaskCanceledException ex) when (ex.InnerException is TimeoutException)\r\n        {\r\n            _logger.LogWarning("External API health check timed out");\r\n            return HealthCheckResult.Unhealthy("External API health check timed out", ex);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "External API health check failed");\r\n            return HealthCheckResult.Unhealthy("External API health check failed", ex);\r\n        }\r\n    }\r\n}\r\n\r\n// HealthChecks/MemoryHealthCheck.cs\r\npublic class MemoryHealthCheck : IHealthCheck\r\n{\r\n    private readonly ILogger<MemoryHealthCheck> _logger;\r\n    private const long ThresholdBytes = 1024 * 1024 * 1024; // 1 GB\r\n\r\n    public MemoryHealthCheck(ILogger<MemoryHealthCheck> logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        try\r\n        {\r\n            var process = Process.GetCurrentProcess();\r\n            var workingSet = process.WorkingSet64;\r\n            var gcTotalMemory = GC.GetTotalMemory(false);\r\n\r\n            var data = new Dictionary<string, object>\r\n            {\r\n                ["working_set_mb"] = workingSet / (1024 * 1024),\r\n                ["gc_total_memory_mb"] = gcTotalMemory / (1024 * 1024),\r\n                ["gen0_collections"] = GC.CollectionCount(0),\r\n                ["gen1_collections"] = GC.CollectionCount(1),\r\n                ["gen2_collections"] = GC.CollectionCount(2),\r\n                ["check_time"] = DateTime.UtcNow\r\n            };\r\n\r\n            if (workingSet > ThresholdBytes)\r\n            {\r\n                return Task.FromResult(HealthCheckResult.Degraded(\r\n                    $"Memory usage is high: {workingSet / (1024 * 1024)} MB", null, data));\r\n            }\r\n\r\n            return Task.FromResult(HealthCheckResult.Healthy(\r\n                $"Memory usage is normal: {workingSet / (1024 * 1024)} MB", data));\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Memory health check failed");\r\n            return Task.FromResult(HealthCheckResult.Unhealthy("Memory health check failed", ex));\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Load Balancer Integration"}),": Determine which instances should receive traffic"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Container Orchestration"}),": Kubernetes liveness and readiness probes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Monitoring Systems"}),": Automated health monitoring and alerting"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Deployment Strategies"}),": Blue-green and rolling deployments"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Auto-scaling"}),": Scale up/down based on application health"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Circuit Breaker Patterns"}),": Fail fast when dependencies are unhealthy"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Use Health Checks when:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Running in containerized or orchestrated environments"}),"\n",(0,a.jsx)(n.li,{children:"Using load balancers for traffic distribution"}),"\n",(0,a.jsx)(n.li,{children:"Need automated monitoring and alerting"}),"\n",(0,a.jsx)(n.li,{children:"Implementing high-availability architectures"}),"\n",(0,a.jsx)(n.li,{children:"Running microservices that depend on external services"}),"\n",(0,a.jsx)(n.li,{children:"Need visibility into application and dependency health"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Consider alternatives when:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Simple applications with no external dependencies"}),"\n",(0,a.jsx)(n.li,{children:"Development or testing environments only"}),"\n",(0,a.jsx)(n.li,{children:"Applications that don't require high availability"}),"\n",(0,a.jsx)(n.li,{children:"Legacy systems that can't be easily modified"}),"\n",(0,a.jsx)(n.li,{children:"When basic uptime monitoring is sufficient"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"market-alternatives--proscons",children:"Market Alternatives & Pros/Cons"}),"\n",(0,a.jsx)(n.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Custom HTTP endpoints"}),": Simple health status endpoints"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Application Performance Monitoring"}),": New Relic, Datadog health monitoring"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Infrastructure monitoring"}),": Nagios, Zabbix, Prometheus"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cloud provider health checks"}),": AWS ELB, Azure Load Balancer"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Service mesh health checks"}),": Istio, Linkerd health monitoring"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"pros",children:"Pros:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Built into .NET ecosystem"}),"\n",(0,a.jsx)(n.li,{children:"Standardized approach across applications"}),"\n",(0,a.jsx)(n.li,{children:"Integration with monitoring and orchestration systems"}),"\n",(0,a.jsx)(n.li,{children:"Customizable and extensible"}),"\n",(0,a.jsx)(n.li,{children:"Minimal performance overhead"}),"\n",(0,a.jsx)(n.li,{children:"Rich reporting capabilities"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"cons",children:"Cons:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Requires proper implementation to be effective"}),"\n",(0,a.jsx)(n.li,{children:"Can add complexity to simple applications"}),"\n",(0,a.jsx)(n.li,{children:"Health check failures might not always indicate real issues"}),"\n",(0,a.jsx)(n.li,{children:"Requires monitoring system integration for full value"}),"\n",(0,a.jsx)(n.li,{children:"Potential security considerations for exposed endpoints"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"complete-runnable-sample",children:"Complete Runnable Sample"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Production-Ready Health Checks Implementation:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Program.cs - Complete health checks setup\r\nusing Microsoft.Extensions.Diagnostics.HealthChecks;\r\nusing System.Text.Json;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add services\r\nbuilder.Services.AddControllers();\r\nbuilder.Services.AddHttpClient<ExternalApiHealthCheck>();\r\n\r\n// Configure health checks with different tags\r\nbuilder.Services.AddHealthChecks()\r\n    // Readiness checks - required for the app to be ready to serve traffic\r\n    .AddCheck<DatabaseHealthCheck>("database", HealthStatus.Unhealthy, new[] { "ready", "database" })\r\n    .AddCheck<RedisHealthCheck>("redis", HealthStatus.Unhealthy, new[] { "ready", "cache" })\r\n\r\n    // Liveness checks - required for the app to be considered alive\r\n    .AddCheck("self", () => HealthCheckResult.Healthy("Application is running"), new[] { "live" })\r\n    .AddCheck<MemoryHealthCheck>("memory", HealthStatus.Degraded, new[] { "live", "memory" })\r\n\r\n    // Optional dependency checks - can be degraded without failing\r\n    .AddCheck<ExternalApiHealthCheck>("external-api", HealthStatus.Degraded, new[] { "external" })\r\n    .AddCheck("disk-space", () =>\r\n    {\r\n        var drives = DriveInfo.GetDrives().Where(d => d.IsReady);\r\n        var criticalDrives = drives.Where(d => d.AvailableFreeSpace < d.TotalSize * 0.1);\r\n\r\n        if (criticalDrives.Any())\r\n        {\r\n            return HealthCheckResult.Degraded($"Low disk space on: {string.Join(", ", criticalDrives.Select(d => d.Name))}");\r\n        }\r\n\r\n        return HealthCheckResult.Healthy("Disk space is adequate");\r\n    }, new[] { "infrastructure" });\r\n\r\n// Add health checks UI for development\r\nif (builder.Environment.IsDevelopment())\r\n{\r\n    builder.Services.AddHealthChecksUI(options =>\r\n    {\r\n        options.SetEvaluationTimeInSeconds(15);\r\n        options.MaximumHistoryEntriesPerEndpoint(100);\r\n        options.AddHealthCheckEndpoint("API Health", "/health");\r\n        options.AddHealthCheckEndpoint("Ready Check", "/health/ready");\r\n        options.AddHealthCheckEndpoint("Live Check", "/health/live");\r\n    }).AddInMemoryStorage();\r\n}\r\n\r\nvar app = builder.Build();\r\n\r\n// Configure health check endpoints\r\napp.MapHealthChecks("/health", new HealthCheckOptions\r\n{\r\n    ResponseWriter = WriteDetailedHealthCheckResponse,\r\n    AllowCachingResponses = false\r\n});\r\n\r\napp.MapHealthChecks("/health/ready", new HealthCheckOptions\r\n{\r\n    Predicate = check => check.Tags.Contains("ready"),\r\n    ResponseWriter = WriteDetailedHealthCheckResponse,\r\n    AllowCachingResponses = false\r\n});\r\n\r\napp.MapHealthChecks("/health/live", new HealthCheckOptions\r\n{\r\n    Predicate = check => check.Tags.Contains("live"),\r\n    ResponseWriter = WriteSimpleHealthCheckResponse,\r\n    AllowCachingResponses = false\r\n});\r\n\r\n// Kubernetes-style probes\r\napp.MapHealthChecks("/readyz", new HealthCheckOptions\r\n{\r\n    Predicate = check => check.Tags.Contains("ready"),\r\n    ResponseWriter = WriteSimpleHealthCheckResponse\r\n});\r\n\r\napp.MapHealthChecks("/livez", new HealthCheckOptions\r\n{\r\n    Predicate = check => check.Tags.Contains("live"),\r\n    ResponseWriter = WriteSimpleHealthCheckResponse\r\n});\r\n\r\n// Health checks UI (development only)\r\nif (app.Environment.IsDevelopment())\r\n{\r\n    app.MapHealthChecksUI(options => options.UIPath = "/health-ui");\r\n}\r\n\r\napp.MapControllers();\r\napp.Run();\r\n\r\n// Detailed response writer\r\nstatic async Task WriteDetailedHealthCheckResponse(HttpContext context, HealthReport report)\r\n{\r\n    context.Response.ContentType = "application/json";\r\n\r\n    var response = new\r\n    {\r\n        status = report.Status.ToString(),\r\n        totalDuration = $"{report.TotalDuration.TotalMilliseconds:F2}ms",\r\n        timestamp = DateTime.UtcNow.ToString("O"),\r\n        checks = report.Entries.ToDictionary(\r\n            kvp => kvp.Key,\r\n            kvp => new\r\n            {\r\n                status = kvp.Value.Status.ToString(),\r\n                duration = $"{kvp.Value.Duration.TotalMilliseconds:F2}ms",\r\n                description = kvp.Value.Description,\r\n                data = kvp.Value.Data,\r\n                exception = kvp.Value.Exception?.Message,\r\n                tags = kvp.Value.Tags\r\n            })\r\n    };\r\n\r\n    var json = JsonSerializer.Serialize(response, new JsonSerializerOptions\r\n    {\r\n        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\r\n        WriteIndented = true\r\n    });\r\n\r\n    await context.Response.WriteAsync(json);\r\n}\r\n\r\n// Simple response writer for load balancers\r\nstatic async Task WriteSimpleHealthCheckResponse(HttpContext context, HealthReport report)\r\n{\r\n    context.Response.ContentType = "text/plain";\r\n\r\n    var status = report.Status switch\r\n    {\r\n        HealthStatus.Healthy => "Healthy",\r\n        HealthStatus.Degraded => "Degraded",\r\n        HealthStatus.Unhealthy => "Unhealthy",\r\n        _ => "Unknown"\r\n    };\r\n\r\n    await context.Response.WriteAsync(status);\r\n}\r\n\r\n// Docker health check script\r\n// docker-healthcheck.sh\r\n#!/bin/bash\r\ncurl -f http://localhost:8080/health/live || exit 1\r\n\r\n// Kubernetes deployment with health checks\r\n// k8s-deployment.yaml\r\napiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: hotel-management-api\r\nspec:\r\n  replicas: 3\r\n  selector:\r\n    matchLabels:\r\n      app: hotel-management-api\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: hotel-management-api\r\n    spec:\r\n      containers:\r\n      - name: api\r\n        image: hotel-management-api:latest\r\n        ports:\r\n        - containerPort: 8080\r\n        livenessProbe:\r\n          httpGet:\r\n            path: /livez\r\n            port: 8080\r\n          initialDelaySeconds: 30\r\n          periodSeconds: 10\r\n          timeoutSeconds: 5\r\n          failureThreshold: 3\r\n        readinessProbe:\r\n          httpGet:\r\n            path: /readyz\r\n            port: 8080\r\n          initialDelaySeconds: 5\r\n          periodSeconds: 5\r\n          timeoutSeconds: 3\r\n          failureThreshold: 3\r\n        startupProbe:\r\n          httpGet:\r\n            path: /health\r\n            port: 8080\r\n          initialDelaySeconds: 10\r\n          periodSeconds: 10\r\n          timeoutSeconds: 5\r\n          failureThreshold: 30\r\n        resources:\r\n          requests:\r\n            memory: "256Mi"\r\n            cpu: "250m"\r\n          limits:\r\n            memory: "512Mi"\r\n            cpu: "500m"\n'})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);