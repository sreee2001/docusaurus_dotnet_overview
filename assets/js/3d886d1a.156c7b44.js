"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[7194],{729:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Topics/AdvancedTopics/EventSourcing","title":"EventSourcing","description":"54. Event Sourcing","source":"@site/docs/Topics/12_AdvancedTopics/54_EventSourcing.md","sourceDirName":"Topics/12_AdvancedTopics","slug":"/Topics/AdvancedTopics/EventSourcing","permalink":"/docusaurus_dotnet_overview/docs/Topics/AdvancedTopics/EventSourcing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":54,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"GraphQL","permalink":"/docusaurus_dotnet_overview/docs/Topics/AdvancedTopics/GraphQL"},"next":{"title":"CommandQueryResponsibilitySegregation","permalink":"/docusaurus_dotnet_overview/docs/Topics/AdvancedTopics/CommandQueryResponsibilitySegregation"}}');var i=r(4848),o=r(8453);const a={},s=void 0,c={},l=[{value:"54. Event Sourcing",id:"54-event-sourcing",level:2},{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition",id:"official-definition",level:2},{value:"Setup/Usage with .NET 8+ Code",id:"setupusage-with-net-8-code",level:2},{value:"Use Cases",id:"use-cases",level:3},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Market Alternatives &amp; Pros/Cons",id:"market-alternatives--proscons",level:3},{value:"Alternatives:",id:"alternatives",level:3},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Complete Runnable Sample",id:"complete-runnable-sample",level:3}];function d(n){const e={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"54-event-sourcing",children:"54. Event Sourcing"}),"\n",(0,i.jsx)(e.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,i.jsx)(e.p,{children:"Event Sourcing is an architectural pattern where state changes are stored as a sequence of events rather than storing just the current state. Instead of updating records in place, every change is appended as an event to an immutable log, allowing the system to reconstruct any past state and providing a complete audit trail."}),"\n",(0,i.jsx)(e.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,i.jsx)(e.p,{children:"Event Sourcing ensures that all changes to application state are stored as a sequence of events. Not just can we query these events, we can also use the event log to reconstruct past states, and as a foundation to automatically adjust the state to cope with retroactive changes."}),"\n",(0,i.jsx)(e.h2,{id:"setupusage-with-net-8-code",children:"Setup/Usage with .NET 8+ Code"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Installation:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"dotnet add package EventStore.Client.Grpc.Streams\r\ndotnet add package MediatR\r\ndotnet add package System.Text.Json\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Event Base Classes:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"// Events/DomainEvent.cs\r\npublic abstract record DomainEvent\r\n{\r\n    public Guid Id { get; init; } = Guid.NewGuid();\r\n    public DateTime Timestamp { get; init; } = DateTime.UtcNow;\r\n    public string EventType => GetType().Name;\r\n    public int Version { get; init; } = 1;\r\n}\r\n\r\n// Events/BookingEvents.cs\r\npublic record BookingCreatedEvent(\r\n    Guid BookingId,\r\n    string CustomerId,\r\n    int RoomId,\r\n    DateTime CheckIn,\r\n    DateTime CheckOut,\r\n    decimal TotalAmount) : DomainEvent;\r\n\r\npublic record BookingConfirmedEvent(\r\n    Guid BookingId,\r\n    DateTime ConfirmedAt) : DomainEvent;\r\n\r\npublic record BookingCancelledEvent(\r\n    Guid BookingId,\r\n    string Reason,\r\n    DateTime CancelledAt) : DomainEvent;\r\n\r\npublic record PaymentProcessedEvent(\r\n    Guid BookingId,\r\n    decimal Amount,\r\n    string PaymentMethod,\r\n    string TransactionId) : DomainEvent;\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Event Store Implementation:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// Infrastructure/EventStore.cs\r\nusing EventStore.Client;\r\nusing System.Text.Json;\r\n\r\npublic interface IEventStore\r\n{\r\n    Task SaveEventsAsync(string streamName, IEnumerable<DomainEvent> events, long expectedVersion);\r\n    Task<IEnumerable<DomainEvent>> GetEventsAsync(string streamName);\r\n    Task<IEnumerable<DomainEvent>> GetEventsAsync(string streamName, long fromVersion);\r\n}\r\n\r\npublic class EventStoreRepository : IEventStore\r\n{\r\n    private readonly EventStoreClient _client;\r\n    private readonly JsonSerializerOptions _jsonOptions;\r\n\r\n    public EventStoreRepository(EventStoreClient client)\r\n    {\r\n        _client = client;\r\n        _jsonOptions = new JsonSerializerOptions\r\n        {\r\n            PropertyNamingPolicy = JsonNamingPolicy.CamelCase\r\n        };\r\n    }\r\n\r\n    public async Task SaveEventsAsync(string streamName, IEnumerable<DomainEvent> events, long expectedVersion)\r\n    {\r\n        var eventData = events.Select(evt => new EventData(\r\n            Uuid.NewUuid(),\r\n            evt.EventType,\r\n            JsonSerializer.SerializeToUtf8Bytes(evt, evt.GetType(), _jsonOptions)\r\n        ));\r\n\r\n        var revision = expectedVersion == -1 ? StreamRevision.None : StreamRevision.FromInt64(expectedVersion);\r\n\r\n        await _client.AppendToStreamAsync(\r\n            streamName,\r\n            revision,\r\n            eventData);\r\n    }\r\n\r\n    public async Task<IEnumerable<DomainEvent>> GetEventsAsync(string streamName)\r\n    {\r\n        return await GetEventsAsync(streamName, 0);\r\n    }\r\n\r\n    public async Task<IEnumerable<DomainEvent>> GetEventsAsync(string streamName, long fromVersion)\r\n    {\r\n        var events = new List<DomainEvent>();\r\n\r\n        try\r\n        {\r\n            var result = _client.ReadStreamAsync(\r\n                Direction.Forwards,\r\n                streamName,\r\n                StreamPosition.FromInt64(fromVersion));\r\n\r\n            await foreach (var evt in result)\r\n            {\r\n                var eventType = Type.GetType($"HotelManagement.Events.{evt.Event.EventType}");\r\n                if (eventType != null)\r\n                {\r\n                    var eventData = JsonSerializer.Deserialize(evt.Event.Data.Span, eventType, _jsonOptions);\r\n                    if (eventData is DomainEvent domainEvent)\r\n                    {\r\n                        events.Add(domainEvent);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (StreamNotFoundException)\r\n        {\r\n            // Stream doesn\'t exist yet, return empty list\r\n        }\r\n\r\n        return events;\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Aggregate Root with Event Sourcing:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// Domain/BookingAggregate.cs\r\npublic class BookingAggregate\r\n{\r\n    private readonly List<DomainEvent> _uncommittedEvents = new();\r\n\r\n    public Guid Id { get; private set; }\r\n    public string CustomerId { get; private set; } = string.Empty;\r\n    public int RoomId { get; private set; }\r\n    public DateTime CheckIn { get; private set; }\r\n    public DateTime CheckOut { get; private set; }\r\n    public decimal TotalAmount { get; private set; }\r\n    public BookingStatus Status { get; private set; }\r\n    public long Version { get; private set; } = -1;\r\n\r\n    // For reconstruction from events\r\n    public BookingAggregate() { }\r\n\r\n    // For creating new booking\r\n    public BookingAggregate(Guid id, string customerId, int roomId,\r\n        DateTime checkIn, DateTime checkOut, decimal totalAmount)\r\n    {\r\n        var @event = new BookingCreatedEvent(id, customerId, roomId, checkIn, checkOut, totalAmount);\r\n        Apply(@event);\r\n        _uncommittedEvents.Add(@event);\r\n    }\r\n\r\n    public void ConfirmBooking()\r\n    {\r\n        if (Status != BookingStatus.Pending)\r\n            throw new InvalidOperationException("Booking can only be confirmed when pending");\r\n\r\n        var @event = new BookingConfirmedEvent(Id, DateTime.UtcNow);\r\n        Apply(@event);\r\n        _uncommittedEvents.Add(@event);\r\n    }\r\n\r\n    public void CancelBooking(string reason)\r\n    {\r\n        if (Status == BookingStatus.Cancelled)\r\n            throw new InvalidOperationException("Booking is already cancelled");\r\n\r\n        var @event = new BookingCancelledEvent(Id, reason, DateTime.UtcNow);\r\n        Apply(@event);\r\n        _uncommittedEvents.Add(@event);\r\n    }\r\n\r\n    public void ProcessPayment(decimal amount, string paymentMethod, string transactionId)\r\n    {\r\n        if (Status != BookingStatus.Confirmed)\r\n            throw new InvalidOperationException("Payment can only be processed for confirmed bookings");\r\n\r\n        var @event = new PaymentProcessedEvent(Id, amount, paymentMethod, transactionId);\r\n        Apply(@event);\r\n        _uncommittedEvents.Add(@event);\r\n    }\r\n\r\n    // Apply events to rebuild state\r\n    public void Apply(DomainEvent @event)\r\n    {\r\n        switch (@event)\r\n        {\r\n            case BookingCreatedEvent created:\r\n                Id = created.BookingId;\r\n                CustomerId = created.CustomerId;\r\n                RoomId = created.RoomId;\r\n                CheckIn = created.CheckIn;\r\n                CheckOut = created.CheckOut;\r\n                TotalAmount = created.TotalAmount;\r\n                Status = BookingStatus.Pending;\r\n                break;\r\n\r\n            case BookingConfirmedEvent confirmed:\r\n                Status = BookingStatus.Confirmed;\r\n                break;\r\n\r\n            case BookingCancelledEvent cancelled:\r\n                Status = BookingStatus.Cancelled;\r\n                break;\r\n\r\n            case PaymentProcessedEvent payment:\r\n                Status = BookingStatus.Paid;\r\n                break;\r\n        }\r\n\r\n        Version++;\r\n    }\r\n\r\n    public void LoadFromHistory(IEnumerable<DomainEvent> events)\r\n    {\r\n        foreach (var @event in events)\r\n        {\r\n            Apply(@event);\r\n        }\r\n    }\r\n\r\n    public IEnumerable<DomainEvent> GetUncommittedEvents() => _uncommittedEvents.AsReadOnly();\r\n\r\n    public void MarkEventsAsCommitted() => _uncommittedEvents.Clear();\r\n}\r\n\r\npublic enum BookingStatus\r\n{\r\n    Pending,\r\n    Confirmed,\r\n    Cancelled,\r\n    Paid\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Repository Pattern with Event Sourcing:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// Infrastructure/BookingRepository.cs\r\npublic interface IBookingRepository\r\n{\r\n    Task<BookingAggregate?> GetByIdAsync(Guid id);\r\n    Task SaveAsync(BookingAggregate aggregate);\r\n}\r\n\r\npublic class EventSourcedBookingRepository : IBookingRepository\r\n{\r\n    private readonly IEventStore _eventStore;\r\n\r\n    public EventSourcedBookingRepository(IEventStore eventStore)\r\n    {\r\n        _eventStore = eventStore;\r\n    }\r\n\r\n    public async Task<BookingAggregate?> GetByIdAsync(Guid id)\r\n    {\r\n        var streamName = $"booking-{id}";\r\n        var events = await _eventStore.GetEventsAsync(streamName);\r\n\r\n        if (!events.Any())\r\n            return null;\r\n\r\n        var aggregate = new BookingAggregate();\r\n        aggregate.LoadFromHistory(events);\r\n        return aggregate;\r\n    }\r\n\r\n    public async Task SaveAsync(BookingAggregate aggregate)\r\n    {\r\n        var streamName = $"booking-{aggregate.Id}";\r\n        var uncommittedEvents = aggregate.GetUncommittedEvents();\r\n\r\n        if (uncommittedEvents.Any())\r\n        {\r\n            await _eventStore.SaveEventsAsync(streamName, uncommittedEvents, aggregate.Version - uncommittedEvents.Count());\r\n            aggregate.MarkEventsAsCommitted();\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Projection for Read Models:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// Projections/BookingProjection.cs\r\npublic class BookingProjection\r\n{\r\n    public Guid Id { get; set; }\r\n    public string CustomerId { get; set; } = string.Empty;\r\n    public int RoomId { get; set; }\r\n    public DateTime CheckIn { get; set; }\r\n    public DateTime CheckOut { get; set; }\r\n    public decimal TotalAmount { get; set; }\r\n    public string Status { get; set; } = string.Empty;\r\n    public DateTime CreatedAt { get; set; }\r\n    public DateTime? ConfirmedAt { get; set; }\r\n    public DateTime? CancelledAt { get; set; }\r\n    public string? CancellationReason { get; set; }\r\n}\r\n\r\n// Projections/BookingProjectionHandler.cs\r\npublic class BookingProjectionHandler :\r\n    INotificationHandler<BookingCreatedEvent>,\r\n    INotificationHandler<BookingConfirmedEvent>,\r\n    INotificationHandler<BookingCancelledEvent>\r\n{\r\n    private readonly HotelDbContext _context;\r\n\r\n    public BookingProjectionHandler(HotelDbContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public async Task Handle(BookingCreatedEvent notification, CancellationToken cancellationToken)\r\n    {\r\n        var projection = new BookingProjection\r\n        {\r\n            Id = notification.BookingId,\r\n            CustomerId = notification.CustomerId,\r\n            RoomId = notification.RoomId,\r\n            CheckIn = notification.CheckIn,\r\n            CheckOut = notification.CheckOut,\r\n            TotalAmount = notification.TotalAmount,\r\n            Status = "Pending",\r\n            CreatedAt = notification.Timestamp\r\n        };\r\n\r\n        _context.BookingProjections.Add(projection);\r\n        await _context.SaveChangesAsync(cancellationToken);\r\n    }\r\n\r\n    public async Task Handle(BookingConfirmedEvent notification, CancellationToken cancellationToken)\r\n    {\r\n        var projection = await _context.BookingProjections\r\n            .FindAsync(notification.BookingId, cancellationToken);\r\n\r\n        if (projection != null)\r\n        {\r\n            projection.Status = "Confirmed";\r\n            projection.ConfirmedAt = notification.ConfirmedAt;\r\n            await _context.SaveChangesAsync(cancellationToken);\r\n        }\r\n    }\r\n\r\n    public async Task Handle(BookingCancelledEvent notification, CancellationToken cancellationToken)\r\n    {\r\n        var projection = await _context.BookingProjections\r\n            .FindAsync(notification.BookingId, cancellationToken);\r\n\r\n        if (projection != null)\r\n        {\r\n            projection.Status = "Cancelled";\r\n            projection.CancelledAt = notification.CancelledAt;\r\n            projection.CancellationReason = notification.Reason;\r\n            await _context.SaveChangesAsync(cancellationToken);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Audit Requirements"}),": Complete audit trail of all changes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Financial Systems"}),": Immutable transaction history"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Temporal Queries"}),': "What was the state at time X?"']}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Event-Driven Architectures"}),": Natural fit for event-driven systems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Debugging and Analytics"}),": Rich historical data for analysis"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Regulatory Compliance"}),": Immutable record of business events"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Use Event Sourcing when:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Need complete audit trail"}),"\n",(0,i.jsx)(e.li,{children:"Temporal queries are important"}),"\n",(0,i.jsx)(e.li,{children:"Building event-driven systems"}),"\n",(0,i.jsx)(e.li,{children:"Regulatory compliance requirements"}),"\n",(0,i.jsx)(e.li,{children:"Complex business processes with state transitions"}),"\n",(0,i.jsx)(e.li,{children:"Need to rebuild state from history"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Consider alternatives when:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Simple CRUD operations"}),"\n",(0,i.jsx)(e.li,{children:"Limited development team experience"}),"\n",(0,i.jsx)(e.li,{children:"Real-time read performance is critical"}),"\n",(0,i.jsx)(e.li,{children:"Storage costs are a major concern"}),"\n",(0,i.jsx)(e.li,{children:"Simple domain logic"}),"\n",(0,i.jsx)(e.li,{children:"Need for simplicity outweighs benefits"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"market-alternatives--proscons",children:"Market Alternatives & Pros/Cons"}),"\n",(0,i.jsx)(e.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Change Data Capture (CDC)"}),": Database-level change tracking"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Audit Tables"}),": Traditional audit logging"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Event Streaming"}),": Kafka, Azure Event Hubs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"CQRS without Event Sourcing"}),": Separate read/write models"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Traditional State Storage"}),": Standard CRUD operations"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"pros",children:"Pros:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Complete audit trail"}),"\n",(0,i.jsx)(e.li,{children:"Natural fit for event-driven architecture"}),"\n",(0,i.jsx)(e.li,{children:"Ability to reconstruct any past state"}),"\n",(0,i.jsx)(e.li,{children:"Excellent for debugging and analysis"}),"\n",(0,i.jsx)(e.li,{children:"Scalable event processing"}),"\n",(0,i.jsx)(e.li,{children:"Strong consistency guarantees"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"cons",children:"Cons:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Increased complexity"}),"\n",(0,i.jsx)(e.li,{children:"Event schema evolution challenges"}),"\n",(0,i.jsx)(e.li,{children:"Storage requirements grow over time"}),"\n",(0,i.jsx)(e.li,{children:"Query complexity for current state"}),"\n",(0,i.jsx)(e.li,{children:"Learning curve for development teams"}),"\n",(0,i.jsx)(e.li,{children:"Eventual consistency in projections"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"complete-runnable-sample",children:"Complete Runnable Sample"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Program.cs Integration:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// Program.cs\r\nusing EventStore.Client;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add EventStore client\r\nvar eventStoreSettings = EventStoreClientSettings.Create("esdb://localhost:2113?tls=false");\r\nbuilder.Services.AddSingleton(new EventStoreClient(eventStoreSettings));\r\n\r\n// Add Event Sourcing services\r\nbuilder.Services.AddScoped<IEventStore, EventStoreRepository>();\r\nbuilder.Services.AddScoped<IBookingRepository, EventSourcedBookingRepository>();\r\n\r\n// Add MediatR for projections\r\nbuilder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));\r\n\r\n// Add Entity Framework for projections\r\nbuilder.Services.AddDbContext<HotelDbContext>(options =>\r\n    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));\r\n\r\nvar app = builder.Build();\r\n\r\n// Example usage\r\napp.MapPost("/bookings", async (CreateBookingCommand command, IBookingRepository repository) =>\r\n{\r\n    var booking = new BookingAggregate(\r\n        Guid.NewGuid(),\r\n        command.CustomerId,\r\n        command.RoomId,\r\n        command.CheckIn,\r\n        command.CheckOut,\r\n        command.TotalAmount);\r\n\r\n    await repository.SaveAsync(booking);\r\n    return Results.Ok(booking.Id);\r\n});\r\n\r\napp.MapPut("/bookings/{id}/confirm", async (Guid id, IBookingRepository repository) =>\r\n{\r\n    var booking = await repository.GetByIdAsync(id);\r\n    if (booking == null) return Results.NotFound();\r\n\r\n    booking.ConfirmBooking();\r\n    await repository.SaveAsync(booking);\r\n    return Results.Ok();\r\n});\r\n\r\n// Docker Compose for EventStore\r\n/*\r\nversion: \'3.8\'\r\nservices:\r\n  eventstore:\r\n    image: eventstore/eventstore:21.10.0-buster-slim\r\n    environment:\r\n      - EVENTSTORE_CLUSTER_SIZE=1\r\n      - EVENTSTORE_RUN_PROJECTIONS=All\r\n      - EVENTSTORE_START_STANDARD_PROJECTIONS=true\r\n      - EVENTSTORE_EXT_TCP_PORT=1113\r\n      - EVENTSTORE_HTTP_PORT=2113\r\n      - EVENTSTORE_INSECURE=true\r\n      - EVENTSTORE_ENABLE_EXTERNAL_TCP=true\r\n      - EVENTSTORE_ENABLE_ATOM_PUB_OVER_HTTP=true\r\n    ports:\r\n      - "1113:1113"\r\n      - "2113:2113"\r\n    volumes:\r\n      - eventstore-volume-data:/var/lib/eventstore\r\n      - eventstore-volume-logs:/var/log/eventstore\r\n\r\nvolumes:\r\n  eventstore-volume-data:\r\n  eventstore-volume-logs:\r\n*/\r\n\r\napp.Run();\r\n\r\npublic record CreateBookingCommand(\r\n    string CustomerId,\r\n    int RoomId,\r\n    DateTime CheckIn,\r\n    DateTime CheckOut,\r\n    decimal TotalAmount);\n'})})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>s});var t=r(6540);const i={},o=t.createContext(i);function a(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);