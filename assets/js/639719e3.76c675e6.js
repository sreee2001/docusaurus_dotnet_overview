"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[4704],{6700:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Topics/PerformanceAndScalability/MemoryManagement","title":"Memory Management","description":"Short Introduction","source":"@site/docs/Topics/06_PerformanceAndScalability/29_MemoryManagement.md","sourceDirName":"Topics/06_PerformanceAndScalability","slug":"/Topics/PerformanceAndScalability/memory_management","permalink":"/docusaurus_dotnet_overview/docs/Topics/PerformanceAndScalability/memory_management","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"dotnet","permalink":"/docusaurus_dotnet_overview/docs/tags/dotnet"},{"inline":true,"label":"performance","permalink":"/docusaurus_dotnet_overview/docs/tags/performance"},{"inline":true,"label":"optimization","permalink":"/docusaurus_dotnet_overview/docs/tags/optimization"},{"inline":true,"label":"memory","permalink":"/docusaurus_dotnet_overview/docs/tags/memory"},{"inline":true,"label":"management","permalink":"/docusaurus_dotnet_overview/docs/tags/management"}],"version":"current","sidebarPosition":29,"frontMatter":{"slug":"memory_management","title":"Memory Management","tags":["dotnet","performance","optimization","memory","management"]},"sidebar":"tutorialSidebar","previous":{"title":"Performance Optimization","permalink":"/docusaurus_dotnet_overview/docs/Topics/PerformanceAndScalability/performance_optimization"},"next":{"title":"Azure App Service","permalink":"/docusaurus_dotnet_overview/docs/Topics/CloudTechnologies/azure_app_service"}}');var o=r(4848),t=r(8453);const a={slug:"memory_management",title:"Memory Management",tags:["dotnet","performance","optimization","memory","management"]},s="Memory Management",l={},c=[{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition:",id:"official-definition",level:2},{value:"Setup/Usage",id:"setupusage",level:2},{value:"GC Configuration in Program.cs:",id:"gc-configuration-in-programcs",level:3},{value:"Runtime Configuration (runtimeconfig.json):",id:"runtime-configuration-runtimeconfigjson",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"When to Use Memory Optimization:",id:"when-to-use-memory-optimization",level:3},{value:"When Not to Optimize:",id:"when-not-to-optimize",level:3},{value:"Alternatives and Trade-offs",id:"alternatives-and-trade-offs",level:2},{value:"Alternatives:",id:"alternatives",level:3},{value:"Trade-offs:",id:"trade-offs",level:3},{value:"Sample Code and Commands",id:"sample-code-and-commands",level:2},{value:"LOH Management:",id:"loh-management",level:3},{value:"Memory-Efficient String Operations:",id:"memory-efficient-string-operations",level:3},{value:"Weak References for Caches:",id:"weak-references-for-caches",level:3},{value:"IDisposable and Memory Cleanup:",id:"idisposable-and-memory-cleanup",level:3},{value:"Memory Diagnostic Commands:",id:"memory-diagnostic-commands",level:3},{value:"Environment Variables for GC Tuning:",id:"environment-variables-for-gc-tuning",level:3},{value:"GC Tuning Configuration File:",id:"gc-tuning-configuration-file",level:3},{value:"Advanced Memory Profiling:",id:"advanced-memory-profiling",level:3},{value:"PowerShell GC Tuning Commands:",id:"powershell-gc-tuning-commands",level:3},{value:"Memory-Optimized appsettings.json:",id:"memory-optimized-appsettingsjson",level:3}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"memory-management",children:"Memory Management"})}),"\n",(0,o.jsx)(n.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,o.jsx)(n.p,{children:"Memory management in .NET Core involves understanding and optimizing how the runtime allocates, tracks, and frees memory. This includes managing the Large Object Heap (LOH), configuring Garbage Collector modes, and implementing patterns that minimize memory pressure and improve application performance."}),"\n",(0,o.jsx)(n.h2,{id:"official-definition",children:"Official Definition:"}),"\n",(0,o.jsx)(n.p,{children:"Memory management in .NET is the automatic process by which the runtime allocates memory for objects, tracks their usage, and reclaims memory when objects are no longer needed, primarily through the Garbage Collector (GC)."}),"\n",(0,o.jsx)(n.h2,{id:"setupusage",children:"Setup/Usage"}),"\n",(0,o.jsx)(n.h3,{id:"gc-configuration-in-programcs",children:"GC Configuration in Program.cs:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Configure GC settings\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// For server applications - configure server GC\r\nbuilder.Services.Configure<GCSettings>(options =>\r\n{\r\n    // These are typically set via runtime config or environment\r\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"runtime-configuration-runtimeconfigjson",children:"Runtime Configuration (runtimeconfig.json):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\r\n  "runtimeOptions": {\r\n    "configProperties": {\r\n      "System.GC.Server": true,\r\n      "System.GC.Concurrent": true,\r\n      "System.GC.RetainVM": true,\r\n      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"High-throughput applications"})," requiring minimal GC pauses"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Memory-constrained environments"})," needing efficient memory usage"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Long-running services"})," requiring stable memory patterns"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-time applications"})," sensitive to GC pause times"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Large data processing"})," applications working with big objects"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Microservices"})," optimizing for quick startup and low memory footprint"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,o.jsx)(n.h3,{id:"when-to-use-memory-optimization",children:"When to Use Memory Optimization:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Application experiences frequent OutOfMemoryExceptions"}),"\n",(0,o.jsx)(n.li,{children:"GC pauses impact user experience or SLA requirements"}),"\n",(0,o.jsx)(n.li,{children:"Memory usage grows continuously (memory leaks suspected)"}),"\n",(0,o.jsx)(n.li,{children:"Application handles large objects or datasets"}),"\n",(0,o.jsx)(n.li,{children:"Running in memory-constrained environments"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"when-not-to-optimize",children:"When Not to Optimize:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Memory usage is well within acceptable limits"}),"\n",(0,o.jsx)(n.li,{children:"GC performance doesn't impact application requirements"}),"\n",(0,o.jsx)(n.li,{children:"Development effort outweighs memory optimization benefits"}),"\n",(0,o.jsx)(n.li,{children:"Application has short lifespan or minimal memory requirements"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"alternatives-and-trade-offs",children:"Alternatives and Trade-offs"}),"\n",(0,o.jsx)(n.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Increase available memory (scale up approach)"}),"\n",(0,o.jsx)(n.li,{children:"Use external caching systems instead of in-memory caching"}),"\n",(0,o.jsx)(n.li,{children:"Implement object pooling for frequently allocated objects"}),"\n",(0,o.jsx)(n.li,{children:"Use streaming instead of loading entire datasets into memory"}),"\n",(0,o.jsx)(n.li,{children:"Offload memory-intensive operations to separate services"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"trade-offs",children:"Trade-offs:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Memory usage vs CPU usage (compression, lazy loading)"}),"\n",(0,o.jsx)(n.li,{children:"Performance vs memory efficiency"}),"\n",(0,o.jsx)(n.li,{children:"Code complexity vs memory optimization"}),"\n",(0,o.jsx)(n.li,{children:"Startup time vs runtime memory usage"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"sample-code-and-commands",children:"Sample Code and Commands"}),"\n",(0,o.jsx)(n.h3,{id:"loh-management",children:"LOH Management:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Avoiding LOH allocations\r\npublic class EfficientDataProcessor\r\n{\r\n    // Pool large buffers to avoid LOH pressure\r\n    private static readonly ObjectPool<byte[]> _bufferPool =\r\n        new ObjectPool<byte[]>(() => new byte[100_000]); // > 85KB goes to LOH\r\n\r\n    public async Task ProcessLargeDataAsync(Stream dataStream)\r\n    {\r\n        // Rent buffer from pool instead of allocating\r\n        var buffer = _bufferPool.Get();\r\n        try\r\n        {\r\n            int bytesRead;\r\n            while ((bytesRead = await dataStream.ReadAsync(buffer)) > 0)\r\n            {\r\n                ProcessChunk(buffer.AsSpan(0, bytesRead));\r\n            }\r\n        }\r\n        finally\r\n        {\r\n            // Return buffer to pool\r\n            _bufferPool.Return(buffer);\r\n        }\r\n    }\r\n\r\n    private void ProcessChunk(ReadOnlySpan<byte> data)\r\n    {\r\n        // Process data without additional allocations\r\n        for (int i = 0; i < data.Length; i++)\r\n        {\r\n            // Process byte at data[i]\r\n        }\r\n    }\r\n}\r\n\r\n// Simple ObjectPool implementation\r\npublic class ObjectPool<T> where T : class\r\n{\r\n    private readonly ConcurrentQueue<T> _objects = new();\r\n    private readonly Func<T> _objectFactory;\r\n\r\n    public ObjectPool(Func<T> objectFactory)\r\n    {\r\n        _objectFactory = objectFactory;\r\n    }\r\n\r\n    public T Get()\r\n    {\r\n        if (_objects.TryDequeue(out T item))\r\n            return item;\r\n\r\n        return _objectFactory();\r\n    }\r\n\r\n    public void Return(T item)\r\n    {\r\n        _objects.Enqueue(item);\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"memory-efficient-string-operations",children:"Memory-Efficient String Operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class StringOptimizations\r\n{\r\n    // Use StringValues for HTTP headers to avoid allocations\r\n    public void ProcessHeaders(IHeaderDictionary headers)\r\n    {\r\n        if (headers.TryGetValue(\"Authorization\", out StringValues authValue))\r\n        {\r\n            // Process without string allocation\r\n            ProcessAuthHeader(authValue);\r\n        }\r\n    }\r\n\r\n    // Use Span<char> for string manipulation without allocations\r\n    public bool IsValidEmail(ReadOnlySpan<char> email)\r\n    {\r\n        int atIndex = email.IndexOf('@');\r\n        if (atIndex <= 0 || atIndex >= email.Length - 1)\r\n            return false;\r\n\r\n        var localPart = email[..atIndex];\r\n        var domainPart = email[(atIndex + 1)..];\r\n\r\n        return localPart.Length > 0 &&\r\n               domainPart.Length > 0 &&\r\n               domainPart.Contains('.');\r\n    }\r\n\r\n    // Use StringBuilder for multiple concatenations\r\n    public string BuildLargeString(IEnumerable<string> parts)\r\n    {\r\n        var sb = new StringBuilder(capacity: 1024); // Pre-size if possible\r\n\r\n        foreach (var part in parts)\r\n        {\r\n            sb.Append(part);\r\n            sb.Append(Environment.NewLine);\r\n        }\r\n\r\n        return sb.ToString();\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"weak-references-for-caches",children:"Weak References for Caches:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class WeakReferenceCache<TKey, TValue>\r\n    where TKey : notnull\r\n    where TValue : class\r\n{\r\n    private readonly ConcurrentDictionary<TKey, WeakReference<TValue>> _cache = new();\r\n\r\n    public bool TryGet(TKey key, out TValue value)\r\n    {\r\n        value = null;\r\n\r\n        if (_cache.TryGetValue(key, out var weakRef) &&\r\n            weakRef.TryGetTarget(out value))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        // Clean up dead reference\r\n        _cache.TryRemove(key, out _);\r\n        return false;\r\n    }\r\n\r\n    public void Set(TKey key, TValue value)\r\n    {\r\n        _cache[key] = new WeakReference<TValue>(value);\r\n    }\r\n\r\n    public void Cleanup()\r\n    {\r\n        var keysToRemove = new List<TKey>();\r\n\r\n        foreach (var kvp in _cache)\r\n        {\r\n            if (!kvp.Value.TryGetTarget(out _))\r\n            {\r\n                keysToRemove.Add(kvp.Key);\r\n            }\r\n        }\r\n\r\n        foreach (var key in keysToRemove)\r\n        {\r\n            _cache.TryRemove(key, out _);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"idisposable-and-memory-cleanup",children:"IDisposable and Memory Cleanup:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class ResourceManager : IDisposable, IAsyncDisposable\r\n{\r\n    private readonly FileStream _fileStream;\r\n    private readonly HttpClient _httpClient;\r\n    private bool _disposed = false;\r\n\r\n    public ResourceManager(string filePath)\r\n    {\r\n        _fileStream = new FileStream(filePath, FileMode.Create);\r\n        _httpClient = new HttpClient();\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        Dispose(disposing: true);\r\n        GC.SuppressFinalize(this);\r\n    }\r\n\r\n    public async ValueTask DisposeAsync()\r\n    {\r\n        await DisposeAsyncCore();\r\n        Dispose(disposing: false);\r\n        GC.SuppressFinalize(this);\r\n    }\r\n\r\n    protected virtual void Dispose(bool disposing)\r\n    {\r\n        if (!_disposed)\r\n        {\r\n            if (disposing)\r\n            {\r\n                _fileStream?.Dispose();\r\n                _httpClient?.Dispose();\r\n            }\r\n            _disposed = true;\r\n        }\r\n    }\r\n\r\n    protected virtual async ValueTask DisposeAsyncCore()\r\n    {\r\n        if (_fileStream != null)\r\n        {\r\n            await _fileStream.DisposeAsync();\r\n        }\r\n\r\n        _httpClient?.Dispose();\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"memory-diagnostic-commands",children:"Memory Diagnostic Commands:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Monitor GC activity\r\ndotnet-counters monitor --process-id <PID> --counters System.Runtime[gen-0-gc-count,gen-1-gc-count,gen-2-gc-count,time-in-gc]\r\n\r\n# Collect memory dump\r\ndotnet-dump collect --process-id <PID>\r\n\r\n# Analyze memory usage patterns\r\ndotnet-trace collect --process-id <PID> --providers Microsoft-Windows-DotNETRuntime:0x1:4\r\n\r\n# Force garbage collection (for testing)\r\ndotnet-gcdump collect --process-id <PID>\n"})}),"\n",(0,o.jsx)(n.h3,{id:"environment-variables-for-gc-tuning",children:"Environment Variables for GC Tuning:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Server GC (for multi-core servers)\r\nset DOTNET_gcServer=1\r\n\r\n# Concurrent GC\r\nset DOTNET_gcConcurrent=1\r\n\r\n# Large pages for LOH\r\nset DOTNET_GCLargePages=1\r\n\r\n# Heap count (for server GC)\r\nset DOTNET_GCHeapCount=4\n"})}),"\n",(0,o.jsx)(n.h3,{id:"gc-tuning-configuration-file",children:"GC Tuning Configuration File:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'// runtimeconfig.template.json\r\n{\r\n  "configProperties": {\r\n    "System.GC.Server": true,\r\n    "System.GC.Concurrent": true,\r\n    "System.GC.RetainVM": true,\r\n    "System.GC.LOHThreshold": 85000,\r\n    "System.GC.HeapCount": 4,\r\n    "System.GC.NoAffinitize": false,\r\n    "System.GC.HeapHardLimit": 2147483648\r\n  }\r\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"advanced-memory-profiling",children:"Advanced Memory Profiling:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Custom memory pressure monitoring\r\npublic class MemoryMonitoringService : BackgroundService\r\n{\r\n    private readonly ILogger<MemoryMonitoringService> _logger;\r\n\r\n    public MemoryMonitoringService(ILogger<MemoryMonitoringService> logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\r\n    {\r\n        while (!stoppingToken.IsCancellationRequested)\r\n        {\r\n            var gcMemoryInfo = GC.GetGCMemoryInfo();\r\n            var totalMemory = GC.GetTotalMemory(false);\r\n            var gen0Collections = GC.CollectionCount(0);\r\n            var gen1Collections = GC.CollectionCount(1);\r\n            var gen2Collections = GC.CollectionCount(2);\r\n\r\n            _logger.LogInformation(\r\n                "Memory Stats - Total: {TotalMemory:N0} bytes, " +\r\n                "Heap Size: {HeapSize:N0} bytes, " +\r\n                "GC Collections - Gen0: {Gen0}, Gen1: {Gen1}, Gen2: {Gen2}",\r\n                totalMemory,\r\n                gcMemoryInfo.HeapSizeBytes,\r\n                gen0Collections,\r\n                gen1Collections,\r\n                gen2Collections);\r\n\r\n            // Alert if memory pressure is high\r\n            if (gcMemoryInfo.MemoryLoadBytes > gcMemoryInfo.HighMemoryLoadThresholdBytes * 0.8)\r\n            {\r\n                _logger.LogWarning("High memory pressure detected. Consider memory optimization.");\r\n\r\n                // Force garbage collection if critical\r\n                if (gcMemoryInfo.MemoryLoadBytes > gcMemoryInfo.HighMemoryLoadThresholdBytes * 0.95)\r\n                {\r\n                    GC.Collect();\r\n                    GC.WaitForPendingFinalizers();\r\n                    GC.Collect();\r\n                }\r\n            }\r\n\r\n            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"powershell-gc-tuning-commands",children:"PowerShell GC Tuning Commands:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-powershell",children:'# Set environment variables for the current session\r\n$env:DOTNET_gcServer = "1"\r\n$env:DOTNET_gcConcurrent = "1"\r\n$env:DOTNET_GCLargePages = "1"\r\n$env:DOTNET_GCHeapCount = "4"\r\n\r\n# Set permanently for user\r\n[Environment]::SetEnvironmentVariable("DOTNET_gcServer", "1", "User")\r\n[Environment]::SetEnvironmentVariable("DOTNET_gcConcurrent", "1", "User")\r\n[Environment]::SetEnvironmentVariable("DOTNET_GCLargePages", "1", "User")\r\n[Environment]::SetEnvironmentVariable("DOTNET_GCHeapCount", "4", "User")\r\n\r\n# View current GC settings\r\ndotnet --info\n'})}),"\n",(0,o.jsx)(n.h3,{id:"memory-optimized-appsettingsjson",children:"Memory-Optimized appsettings.json:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\r\n  "Logging": {\r\n    "LogLevel": {\r\n      "Default": "Information",\r\n      "Microsoft.AspNetCore": "Warning"\r\n    }\r\n  },\r\n  "MemoryCache": {\r\n    "SizeLimit": 104857600,\r\n    "CompactionPercentage": 0.1,\r\n    "ExpirationScanFrequency": "00:05:00"\r\n  },\r\n  "GarbageCollection": {\r\n    "MonitoringEnabled": true,\r\n    "MonitoringInterval": "00:05:00",\r\n    "HighMemoryThreshold": 0.8,\r\n    "CriticalMemoryThreshold": 0.95\r\n  }\r\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var i=r(6540);const o={},t=i.createContext(o);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);