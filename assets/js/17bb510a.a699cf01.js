"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[9300],{8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var o=r(6540);const a={},t=o.createContext(a);function i(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(t.Provider,{value:n},e.children)}},9645:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Topics/DataAccessAndPersistence/AdoDotNet","title":"ADO.NET","description":"ADO.NET is the foundational data access technology in .NET that provides low-level access to data sources. It offers maximum control and performance but requires more code and careful resource management.","source":"@site/docs/Topics/04_DataAccessAndPersistence/20_AdoDotNet.md","sourceDirName":"Topics/04_DataAccessAndPersistence","slug":"/Topics/DataAccessAndPersistence/ado_net","permalink":"/docusaurus_dotnet_overview/docs/Topics/DataAccessAndPersistence/ado_net","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"dotnet","permalink":"/docusaurus_dotnet_overview/docs/tags/dotnet"},{"inline":true,"label":"ADO","permalink":"/docusaurus_dotnet_overview/docs/tags/ado"},{"inline":true,"label":"database","permalink":"/docusaurus_dotnet_overview/docs/tags/database"},{"inline":true,"label":"performance","permalink":"/docusaurus_dotnet_overview/docs/tags/performance"}],"version":"current","sidebarPosition":20,"frontMatter":{"slug":"ado_net","title":"ADO.NET","tags":["dotnet","ADO","database","performance"]},"sidebar":"tutorialSidebar","previous":{"title":"Dapper","permalink":"/docusaurus_dotnet_overview/docs/Topics/DataAccessAndPersistence/dapper"},"next":{"title":"Repository Pattern","permalink":"/docusaurus_dotnet_overview/docs/Topics/DataAccessAndPersistence/repository_pattern"}}');var a=r(4848),t=r(8453);const i={slug:"ado_net",title:"ADO.NET",tags:["dotnet","ADO","database","performance"]},s="ADO.NET",c={},l=[{value:"Official Definition",id:"official-definition",level:2},{value:"Usage",id:"usage",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Use ADO.NET when:",id:"use-adonet-when",level:3},{value:"Don&#39;t use ADO.NET when:",id:"dont-use-adonet-when",level:3},{value:"Market Alternatives and Market Adoption",id:"market-alternatives-and-market-adoption",level:2},{value:"Pros and Cons",id:"pros-and-cons",level:2},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Sample Usage",id:"sample-usage",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"adonet",children:"ADO.NET"})}),"\n",(0,a.jsx)(n.p,{children:"ADO.NET is the foundational data access technology in .NET that provides low-level access to data sources. It offers maximum control and performance but requires more code and careful resource management."}),"\n",(0,a.jsx)(n.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,a.jsx)(n.p,{children:"ADO.NET (ActiveX Data Objects for .NET) is a set of classes that expose data access services for .NET Framework and .NET Core programmers. It provides a bridge between the front-end controls and the back-end database."}),"\n",(0,a.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(n.p,{children:"ADO.NET is included in .NET by default. For SQL Server, install the Microsoft.Data.SqlClient package:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"dotnet add package Microsoft.Data.SqlClient\n"})}),"\n",(0,a.jsx)(n.p,{children:"Basic components include Connection, Command, DataReader, and DataAdapter classes."}),"\n",(0,a.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Maximum performance requirements"}),"\n",(0,a.jsx)(n.li,{children:"Fine-grained control over database operations"}),"\n",(0,a.jsx)(n.li,{children:"Legacy system integration"}),"\n",(0,a.jsx)(n.li,{children:"Complex data processing scenarios"}),"\n",(0,a.jsx)(n.li,{children:"Bulk data operations"}),"\n",(0,a.jsx)(n.li,{children:"Custom connection pooling requirements"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,a.jsx)(n.h3,{id:"use-adonet-when",children:"Use ADO.NET when:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Absolute maximum performance is required"}),"\n",(0,a.jsx)(n.li,{children:"Working with legacy databases or systems"}),"\n",(0,a.jsx)(n.li,{children:"Need precise control over connection management"}),"\n",(0,a.jsx)(n.li,{children:"Implementing custom data access patterns"}),"\n",(0,a.jsx)(n.li,{children:"Building data access frameworks"}),"\n",(0,a.jsx)(n.li,{children:"Processing large datasets efficiently"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"dont-use-adonet-when",children:"Don't use ADO.NET when:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Development speed is prioritized"}),"\n",(0,a.jsx)(n.li,{children:"Team lacks database expertise"}),"\n",(0,a.jsx)(n.li,{children:"Building standard CRUD applications"}),"\n",(0,a.jsx)(n.li,{children:"Need object-relational mapping features"}),"\n",(0,a.jsx)(n.li,{children:"Want to avoid boilerplate code"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"market-alternatives-and-market-adoption",children:"Market Alternatives and Market Adoption"}),"\n",(0,a.jsx)(n.p,{children:"ADO.NET remains the foundation for all .NET data access technologies. While higher-level tools like Entity Framework and Dapper are more commonly used for application development, ADO.NET is still essential for framework development and high-performance scenarios."}),"\n",(0,a.jsx)(n.h2,{id:"pros-and-cons",children:"Pros and Cons"}),"\n",(0,a.jsx)(n.h3,{id:"pros",children:"Pros:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Maximum performance and control"}),"\n",(0,a.jsx)(n.li,{children:"Direct access to all database features"}),"\n",(0,a.jsx)(n.li,{children:"Minimal memory footprint"}),"\n",(0,a.jsx)(n.li,{children:"No abstraction overhead"}),"\n",(0,a.jsx)(n.li,{children:"Supports all data types"}),"\n",(0,a.jsx)(n.li,{children:"Battle-tested and stable"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"cons",children:"Cons:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Verbose and repetitive code"}),"\n",(0,a.jsx)(n.li,{children:"Manual resource management required"}),"\n",(0,a.jsx)(n.li,{children:"No object-relational mapping"}),"\n",(0,a.jsx)(n.li,{children:"Prone to SQL injection if not careful"}),"\n",(0,a.jsx)(n.li,{children:"Requires extensive database knowledge"}),"\n",(0,a.jsx)(n.li,{children:"Time-consuming development"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"sample-usage",children:"Sample Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Package reference: <PackageReference Include="Microsoft.Data.SqlClient" Version="5.1.1" />\r\nusing Microsoft.Data.SqlClient;\r\nusing System.Data;\r\n\r\n// Models\r\npublic class Room\r\n{\r\n    public int Id { get; set; }\r\n    public string RoomNumber { get; set; } = string.Empty;\r\n    public string RoomType { get; set; } = string.Empty;\r\n    public decimal PricePerNight { get; set; }\r\n    public bool IsAvailable { get; set; }\r\n}\r\n\r\npublic class RoomRepository\r\n{\r\n    private readonly string _connectionString;\r\n\r\n    public RoomRepository(string connectionString)\r\n    {\r\n        _connectionString = connectionString;\r\n    }\r\n\r\n    // Query with DataReader\r\n    public async Task<Room?> GetRoomByIdAsync(int roomId)\r\n    {\r\n        using var connection = new SqlConnection(_connectionString);\r\n        await connection.OpenAsync();\r\n\r\n        using var command = new SqlCommand(\r\n            "SELECT Id, RoomNumber, RoomType, PricePerNight, IsAvailable FROM Rooms WHERE Id = @Id",\r\n            connection);\r\n\r\n        command.Parameters.Add(new SqlParameter("@Id", SqlDbType.Int) { Value = roomId });\r\n\r\n        using var reader = await command.ExecuteReaderAsync();\r\n\r\n        if (await reader.ReadAsync())\r\n        {\r\n            return new Room\r\n            {\r\n                Id = reader.GetInt32("Id"),\r\n                RoomNumber = reader.GetString("RoomNumber"),\r\n                RoomType = reader.GetString("RoomType"),\r\n                PricePerNight = reader.GetDecimal("PricePerNight"),\r\n                IsAvailable = reader.GetBoolean("IsAvailable")\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    // Query multiple records\r\n    public async Task<List<Room>> GetAvailableRoomsAsync()\r\n    {\r\n        var rooms = new List<Room>();\r\n\r\n        using var connection = new SqlConnection(_connectionString);\r\n        await connection.OpenAsync();\r\n\r\n        using var command = new SqlCommand(\r\n            "SELECT Id, RoomNumber, RoomType, PricePerNight, IsAvailable FROM Rooms WHERE IsAvailable = 1",\r\n            connection);\r\n\r\n        using var reader = await command.ExecuteReaderAsync();\r\n\r\n        while (await reader.ReadAsync())\r\n        {\r\n            rooms.Add(new Room\r\n            {\r\n                Id = reader.GetInt32("Id"),\r\n                RoomNumber = reader.GetString("RoomNumber"),\r\n                RoomType = reader.GetString("RoomType"),\r\n                PricePerNight = reader.GetDecimal("PricePerNight"),\r\n                IsAvailable = reader.GetBoolean("IsAvailable")\r\n            });\r\n        }\r\n\r\n        return rooms;\r\n    }\r\n\r\n    // Insert with transaction\r\n    public async Task<int> CreateRoomAsync(Room room)\r\n    {\r\n        using var connection = new SqlConnection(_connectionString);\r\n        await connection.OpenAsync();\r\n\r\n        using var transaction = connection.BeginTransaction();\r\n\r\n        try\r\n        {\r\n            using var command = new SqlCommand(\r\n                @"INSERT INTO Rooms (RoomNumber, RoomType, PricePerNight, IsAvailable)\r\n                  VALUES (@RoomNumber, @RoomType, @PricePerNight, @IsAvailable);\r\n                  SELECT CAST(SCOPE_IDENTITY() as int);",\r\n                connection, transaction);\r\n\r\n            command.Parameters.AddRange(new[]\r\n            {\r\n                new SqlParameter("@RoomNumber", SqlDbType.VarChar, 10) { Value = room.RoomNumber },\r\n                new SqlParameter("@RoomType", SqlDbType.VarChar, 50) { Value = room.RoomType },\r\n                new SqlParameter("@PricePerNight", SqlDbType.Decimal) { Value = room.PricePerNight },\r\n                new SqlParameter("@IsAvailable", SqlDbType.Bit) { Value = room.IsAvailable }\r\n            });\r\n\r\n            var newId = (int)await command.ExecuteScalarAsync();\r\n\r\n            await transaction.CommitAsync();\r\n            return newId;\r\n        }\r\n        catch\r\n        {\r\n            await transaction.RollbackAsync();\r\n            throw;\r\n        }\r\n    }\r\n\r\n    // Bulk operations with DataAdapter\r\n    public async Task<List<Room>> GetRoomsWithDataSetAsync()\r\n    {\r\n        using var connection = new SqlConnection(_connectionString);\r\n        var adapter = new SqlDataAdapter("SELECT * FROM Rooms", connection);\r\n        var dataSet = new DataSet();\r\n\r\n        adapter.Fill(dataSet, "Rooms");\r\n\r\n        var rooms = new List<Room>();\r\n        foreach (DataRow row in dataSet.Tables["Rooms"].Rows)\r\n        {\r\n            rooms.Add(new Room\r\n            {\r\n                Id = (int)row["Id"],\r\n                RoomNumber = row["RoomNumber"].ToString()!,\r\n                RoomType = row["RoomType"].ToString()!,\r\n                PricePerNight = (decimal)row["PricePerNight"],\r\n                IsAvailable = (bool)row["IsAvailable"]\r\n            });\r\n        }\r\n\r\n        return rooms;\r\n    }\r\n\r\n    // Stored procedure execution\r\n    public async Task UpdateRoomAvailabilityAsync(int roomId, bool isAvailable)\r\n    {\r\n        using var connection = new SqlConnection(_connectionString);\r\n        await connection.OpenAsync();\r\n\r\n        using var command = new SqlCommand("sp_UpdateRoomAvailability", connection)\r\n        {\r\n            CommandType = CommandType.StoredProcedure\r\n        };\r\n\r\n        command.Parameters.AddRange(new[]\r\n        {\r\n            new SqlParameter("@RoomId", SqlDbType.Int) { Value = roomId },\r\n            new SqlParameter("@IsAvailable", SqlDbType.Bit) { Value = isAvailable }\r\n        });\r\n\r\n        await command.ExecuteNonQueryAsync();\r\n    }\r\n}\r\n\r\n// Usage example\r\nvar connectionString = "Server=localhost;Database=HotelDB;Integrated Security=true;";\r\nvar roomRepository = new RoomRepository(connectionString);\r\n\r\n// Create and retrieve a room\r\nvar newRoom = new Room\r\n{\r\n    RoomNumber = "101",\r\n    RoomType = "Standard",\r\n    PricePerNight = 99.99m,\r\n    IsAvailable = true\r\n};\r\n\r\nvar roomId = await roomRepository.CreateRoomAsync(newRoom);\r\nvar retrievedRoom = await roomRepository.GetRoomByIdAsync(roomId);\r\nvar availableRooms = await roomRepository.GetAvailableRoomsAsync();\n'})})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);