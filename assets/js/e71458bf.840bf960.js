"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[1683],{2363:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Topics/DataAccessAndPersistence/RepositoryPattern","title":"Repository Pattern","description":"The Repository Pattern encapsulates the logic needed to access data sources, centralizing common data access functionality and providing better maintainability and decoupling infrastructure or technology used to access databases from the domain model layer.","source":"@site/docs/Topics/04_DataAccessAndPersistence/21_RepositoryPattern.md","sourceDirName":"Topics/04_DataAccessAndPersistence","slug":"/Topics/DataAccessAndPersistence/repository_pattern","permalink":"/docusaurus_dotnet_overview/docs/Topics/DataAccessAndPersistence/repository_pattern","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"dotnet","permalink":"/docusaurus_dotnet_overview/docs/tags/dotnet"},{"inline":true,"label":"database","permalink":"/docusaurus_dotnet_overview/docs/tags/database"},{"inline":true,"label":"repository_pattern","permalink":"/docusaurus_dotnet_overview/docs/tags/repository-pattern"},{"inline":true,"label":"patterns","permalink":"/docusaurus_dotnet_overview/docs/tags/patterns"},{"inline":true,"label":"design_pattern","permalink":"/docusaurus_dotnet_overview/docs/tags/design-pattern"},{"inline":true,"label":"architecture","permalink":"/docusaurus_dotnet_overview/docs/tags/architecture"}],"version":"current","sidebarPosition":21,"frontMatter":{"slug":"repository_pattern","title":"Repository Pattern","tags":["dotnet","database","repository_pattern","patterns","design_pattern","architecture"]},"sidebar":"tutorialSidebar","previous":{"title":"ADO.NET","permalink":"/docusaurus_dotnet_overview/docs/Topics/DataAccessAndPersistence/ado_net"},"next":{"title":"Unit of Work","permalink":"/docusaurus_dotnet_overview/docs/Topics/DataAccessAndPersistence/unit_of_work"}}');var i=t(4848),o=t(8453);const s={slug:"repository_pattern",title:"Repository Pattern",tags:["dotnet","database","repository_pattern","patterns","design_pattern","architecture"]},a="Repository Pattern",c={},l=[{value:"Official Definition",id:"official-definition",level:2},{value:"Usage",id:"usage",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Use Repository Pattern when:",id:"use-repository-pattern-when",level:3},{value:"Don&#39;t use Repository Pattern when:",id:"dont-use-repository-pattern-when",level:3},{value:"Market Alternatives and Market Adoption",id:"market-alternatives-and-market-adoption",level:2},{value:"Pros and Cons",id:"pros-and-cons",level:2},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Sample Usage",id:"sample-usage",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"repository-pattern",children:"Repository Pattern"})}),"\n",(0,i.jsx)(n.p,{children:"The Repository Pattern encapsulates the logic needed to access data sources, centralizing common data access functionality and providing better maintainability and decoupling infrastructure or technology used to access databases from the domain model layer."}),"\n",(0,i.jsx)(n.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,i.jsx)(n.p,{children:"The Repository Pattern is a design pattern that encapsulates the logic required to access data sources. It centralizes common data access functionality, promoting better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer."}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.p,{children:"Implement by creating interfaces that define data access operations and concrete implementations that handle the actual data access logic. Often combined with dependency injection for better testability."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface IRepository<T>\r\n{\r\n    Task<T?> GetByIdAsync(int id);\r\n    Task<IEnumerable<T>> GetAllAsync();\r\n    Task<T> AddAsync(T entity);\r\n    Task UpdateAsync(T entity);\r\n    Task DeleteAsync(int id);\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Abstracting data access logic from business logic"}),"\n",(0,i.jsx)(n.li,{children:"Supporting multiple data sources or switching between them"}),"\n",(0,i.jsx)(n.li,{children:"Improving testability with mock repositories"}),"\n",(0,i.jsx)(n.li,{children:"Centralizing query logic and data access patterns"}),"\n",(0,i.jsx)(n.li,{children:"Implementing domain-driven design principles"}),"\n",(0,i.jsx)(n.li,{children:"Creating clean architecture boundaries"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,i.jsx)(n.h3,{id:"use-repository-pattern-when",children:"Use Repository Pattern when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Building applications with complex business logic"}),"\n",(0,i.jsx)(n.li,{children:"Need to support multiple data sources"}),"\n",(0,i.jsx)(n.li,{children:"Want to improve testability and maintainability"}),"\n",(0,i.jsx)(n.li,{children:"Implementing clean architecture or DDD"}),"\n",(0,i.jsx)(n.li,{children:"Team needs clear separation of concerns"}),"\n",(0,i.jsx)(n.li,{children:"Planning to switch data access technologies"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"dont-use-repository-pattern-when",children:"Don't use Repository Pattern when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Building simple CRUD applications"}),"\n",(0,i.jsx)(n.li,{children:"Using Entity Framework with direct DbContext access"}),"\n",(0,i.jsx)(n.li,{children:"Team is small and simplicity is preferred"}),"\n",(0,i.jsx)(n.li,{children:"Over-engineering concerns outweigh benefits"}),"\n",(0,i.jsx)(n.li,{children:"Performance is critical and abstraction adds overhead"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"market-alternatives-and-market-adoption",children:"Market Alternatives and Market Adoption"}),"\n",(0,i.jsx)(n.p,{children:"The Repository Pattern is widely adopted in enterprise .NET applications. Alternatives include direct ORM usage (Entity Framework DbContext), Active Record pattern, and Data Access Objects (DAO). Many modern frameworks like Entity Framework already implement repository-like patterns internally."}),"\n",(0,i.jsx)(n.h2,{id:"pros-and-cons",children:"Pros and Cons"}),"\n",(0,i.jsx)(n.h3,{id:"pros",children:"Pros:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Clear separation of concerns"}),"\n",(0,i.jsx)(n.li,{children:"Improved testability"}),"\n",(0,i.jsx)(n.li,{children:"Centralized query logic"}),"\n",(0,i.jsx)(n.li,{children:"Easy to mock for unit tests"}),"\n",(0,i.jsx)(n.li,{children:"Supports multiple data sources"}),"\n",(0,i.jsx)(n.li,{children:"Promotes clean architecture"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"cons",children:"Cons:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Can add unnecessary complexity"}),"\n",(0,i.jsx)(n.li,{children:"Additional abstraction layer"}),"\n",(0,i.jsx)(n.li,{children:"Potential performance overhead"}),"\n",(0,i.jsx)(n.li,{children:"May duplicate ORM functionality"}),"\n",(0,i.jsx)(n.li,{children:"Can become over-engineered"}),"\n",(0,i.jsx)(n.li,{children:"Learning curve for developers"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"sample-usage",children:"Sample Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Package references might include Entity Framework or Dapper\r\nusing Microsoft.EntityFrameworkCore;\r\n\r\n// Domain model\r\npublic class Booking\r\n{\r\n    public int Id { get; set; }\r\n    public int GuestId { get; set; }\r\n    public int RoomId { get; set; }\r\n    public DateTime CheckInDate { get; set; }\r\n    public DateTime CheckOutDate { get; set; }\r\n    public decimal TotalAmount { get; set; }\r\n    public BookingStatus Status { get; set; }\r\n    public DateTime CreatedAt { get; set; }\r\n}\r\n\r\npublic enum BookingStatus\r\n{\r\n    Pending,\r\n    Confirmed,\r\n    CheckedIn,\r\n    CheckedOut,\r\n    Cancelled\r\n}\r\n\r\n// Generic repository interface\r\npublic interface IRepository<T> where T : class\r\n{\r\n    Task<T?> GetByIdAsync(int id);\r\n    Task<IEnumerable<T>> GetAllAsync();\r\n    Task<T> AddAsync(T entity);\r\n    Task UpdateAsync(T entity);\r\n    Task DeleteAsync(int id);\r\n    Task<bool> ExistsAsync(int id);\r\n}\r\n\r\n// Specific repository interface\r\npublic interface IBookingRepository : IRepository<Booking>\r\n{\r\n    Task<IEnumerable<Booking>> GetBookingsByGuestIdAsync(int guestId);\r\n    Task<IEnumerable<Booking>> GetBookingsByDateRangeAsync(DateTime startDate, DateTime endDate);\r\n    Task<IEnumerable<Booking>> GetActiveBookingsAsync();\r\n    Task<bool> IsRoomAvailableAsync(int roomId, DateTime checkIn, DateTime checkOut);\r\n}\r\n\r\n// Entity Framework implementation\r\npublic class BookingRepository : IBookingRepository\r\n{\r\n    private readonly HotelDbContext _context;\r\n\r\n    public BookingRepository(HotelDbContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public async Task<Booking?> GetByIdAsync(int id)\r\n    {\r\n        return await _context.Bookings.FindAsync(id);\r\n    }\r\n\r\n    public async Task<IEnumerable<Booking>> GetAllAsync()\r\n    {\r\n        return await _context.Bookings.ToListAsync();\r\n    }\r\n\r\n    public async Task<Booking> AddAsync(Booking booking)\r\n    {\r\n        booking.CreatedAt = DateTime.UtcNow;\r\n        _context.Bookings.Add(booking);\r\n        await _context.SaveChangesAsync();\r\n        return booking;\r\n    }\r\n\r\n    public async Task UpdateAsync(Booking booking)\r\n    {\r\n        _context.Entry(booking).State = EntityState.Modified;\r\n        await _context.SaveChangesAsync();\r\n    }\r\n\r\n    public async Task DeleteAsync(int id)\r\n    {\r\n        var booking = await _context.Bookings.FindAsync(id);\r\n        if (booking != null)\r\n        {\r\n            _context.Bookings.Remove(booking);\r\n            await _context.SaveChangesAsync();\r\n        }\r\n    }\r\n\r\n    public async Task<bool> ExistsAsync(int id)\r\n    {\r\n        return await _context.Bookings.AnyAsync(b => b.Id == id);\r\n    }\r\n\r\n    // Specific booking methods\r\n    public async Task<IEnumerable<Booking>> GetBookingsByGuestIdAsync(int guestId)\r\n    {\r\n        return await _context.Bookings\r\n            .Where(b => b.GuestId == guestId)\r\n            .OrderByDescending(b => b.CreatedAt)\r\n            .ToListAsync();\r\n    }\r\n\r\n    public async Task<IEnumerable<Booking>> GetBookingsByDateRangeAsync(DateTime startDate, DateTime endDate)\r\n    {\r\n        return await _context.Bookings\r\n            .Where(b => b.CheckInDate >= startDate && b.CheckOutDate <= endDate)\r\n            .ToListAsync();\r\n    }\r\n\r\n    public async Task<IEnumerable<Booking>> GetActiveBookingsAsync()\r\n    {\r\n        var today = DateTime.Today;\r\n        return await _context.Bookings\r\n            .Where(b => b.Status == BookingStatus.Confirmed || b.Status == BookingStatus.CheckedIn)\r\n            .Where(b => b.CheckOutDate >= today)\r\n            .ToListAsync();\r\n    }\r\n\r\n    public async Task<bool> IsRoomAvailableAsync(int roomId, DateTime checkIn, DateTime checkOut)\r\n    {\r\n        return !await _context.Bookings\r\n            .AnyAsync(b => b.RoomId == roomId &&\r\n                          b.Status != BookingStatus.Cancelled &&\r\n                          ((checkIn >= b.CheckInDate && checkIn < b.CheckOutDate) ||\r\n                           (checkOut > b.CheckInDate && checkOut <= b.CheckOutDate) ||\r\n                           (checkIn <= b.CheckInDate && checkOut >= b.CheckOutDate)));\r\n    }\r\n}\r\n\r\n// Service layer using repository\r\npublic class BookingService\r\n{\r\n    private readonly IBookingRepository _bookingRepository;\r\n\r\n    public BookingService(IBookingRepository bookingRepository)\r\n    {\r\n        _bookingRepository = bookingRepository;\r\n    }\r\n\r\n    public async Task<Booking> CreateBookingAsync(int guestId, int roomId, DateTime checkIn, DateTime checkOut, decimal totalAmount)\r\n    {\r\n        // Business logic validation\r\n        if (checkIn >= checkOut)\r\n            throw new ArgumentException("Check-in date must be before check-out date");\r\n\r\n        if (!await _bookingRepository.IsRoomAvailableAsync(roomId, checkIn, checkOut))\r\n            throw new InvalidOperationException("Room is not available for the selected dates");\r\n\r\n        var booking = new Booking\r\n        {\r\n            GuestId = guestId,\r\n            RoomId = roomId,\r\n            CheckInDate = checkIn,\r\n            CheckOutDate = checkOut,\r\n            TotalAmount = totalAmount,\r\n            Status = BookingStatus.Pending\r\n        };\r\n\r\n        return await _bookingRepository.AddAsync(booking);\r\n    }\r\n\r\n    public async Task ConfirmBookingAsync(int bookingId)\r\n    {\r\n        var booking = await _bookingRepository.GetByIdAsync(bookingId);\r\n        if (booking == null)\r\n            throw new ArgumentException("Booking not found");\r\n\r\n        booking.Status = BookingStatus.Confirmed;\r\n        await _bookingRepository.UpdateAsync(booking);\r\n    }\r\n}\r\n\r\n// Dependency injection setup (in Program.cs)\r\npublic class HotelDbContext : DbContext\r\n{\r\n    public HotelDbContext(DbContextOptions<HotelDbContext> options) : base(options) { }\r\n\r\n    public DbSet<Booking> Bookings { get; set; }\r\n}\r\n\r\n// Registration in Program.cs\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddDbContext<HotelDbContext>(options =>\r\n    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));\r\n\r\nbuilder.Services.AddScoped<IBookingRepository, BookingRepository>();\r\nbuilder.Services.AddScoped<BookingService>();\r\n\r\nvar app = builder.Build();\r\n\r\n// Usage in controller\r\n[ApiController]\r\n[Route("api/[controller]")]\r\npublic class BookingsController : ControllerBase\r\n{\r\n    private readonly BookingService _bookingService;\r\n\r\n    public BookingsController(BookingService bookingService)\r\n    {\r\n        _bookingService = bookingService;\r\n    }\r\n\r\n    [HttpPost]\r\n    public async Task<ActionResult<Booking>> CreateBooking([FromBody] CreateBookingRequest request)\r\n    {\r\n        try\r\n        {\r\n            var booking = await _bookingService.CreateBookingAsync(\r\n                request.GuestId,\r\n                request.RoomId,\r\n                request.CheckIn,\r\n                request.CheckOut,\r\n                request.TotalAmount);\r\n\r\n            return CreatedAtAction(nameof(GetBooking), new { id = booking.Id }, booking);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            return BadRequest(ex.Message);\r\n        }\r\n    }\r\n\r\n    [HttpGet("{id}")]\r\n    public async Task<ActionResult<Booking>> GetBooking(int id)\r\n    {\r\n        var booking = await _bookingService._bookingRepository.GetByIdAsync(id);\r\n        return booking == null ? NotFound() : Ok(booking);\r\n    }\r\n}\r\n\r\npublic class CreateBookingRequest\r\n{\r\n    public int GuestId { get; set; }\r\n    public int RoomId { get; set; }\r\n    public DateTime CheckIn { get; set; }\r\n    public DateTime CheckOut { get; set; }\r\n    public decimal TotalAmount { get; set; }\r\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(6540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);