"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[8487],{1796:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"Topics/Testing/TestDrivenDevelopment_TDD","title":"Test Driven Development","description":"Short Introduction","source":"@site/docs/Topics/05_Testing/25_TestDrivenDevelopment_TDD.md","sourceDirName":"Topics/05_Testing","slug":"/Topics/Testing/tdd","permalink":"/docusaurus_dotnet_overview/docs/Topics/Testing/tdd","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"dotnet","permalink":"/docusaurus_dotnet_overview/docs/tags/dotnet"},{"inline":true,"label":"testing","permalink":"/docusaurus_dotnet_overview/docs/tags/testing"},{"inline":true,"label":"tdd","permalink":"/docusaurus_dotnet_overview/docs/tags/tdd"},{"inline":true,"label":"quality","permalink":"/docusaurus_dotnet_overview/docs/tags/quality"},{"inline":true,"label":"pattern","permalink":"/docusaurus_dotnet_overview/docs/tags/pattern"}],"version":"current","sidebarPosition":25,"frontMatter":{"slug":"tdd","title":"Test Driven Development","tags":["dotnet","testing","tdd","quality","pattern"]},"sidebar":"tutorialSidebar","previous":{"title":"Unit Testing","permalink":"/docusaurus_dotnet_overview/docs/Topics/Testing/unit_testing"},"next":{"title":"Integration Testing","permalink":"/docusaurus_dotnet_overview/docs/Topics/Testing/integration_testing"}}');var i=r(4848),s=r(8453);const o={slug:"tdd",title:"Test Driven Development",tags:["dotnet","testing","tdd","quality","pattern"]},l="Test-Driven Development (TDD)",c={},a=[{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition",id:"official-definition",level:2},{value:"TDD Principles and Process",id:"tdd-principles-and-process",level:2},{value:"The Red-Green-Refactor Cycle:",id:"the-red-green-refactor-cycle",level:3},{value:"Core Principles:",id:"core-principles",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Use TDD when:",id:"use-tdd-when",level:3},{value:"Consider alternatives when:",id:"consider-alternatives-when",level:3},{value:"Market Alternatives &amp; Pros/Cons",id:"market-alternatives--proscons",level:2},{value:"Alternatives:",id:"alternatives",level:3},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Benefits of TDD in .NET Development",id:"benefits-of-tdd-in-net-development",level:2},{value:"Code Quality Benefits:",id:"code-quality-benefits",level:3},{value:"Development Process Benefits:",id:"development-process-benefits",level:3},{value:"Long-term Benefits:",id:"long-term-benefits",level:3},{value:"TDD Best Practices for .NET",id:"tdd-best-practices-for-net",level:2},{value:"Common TDD Challenges and Solutions",id:"common-tdd-challenges-and-solutions",level:2},{value:"Setup/Usage with .NET 8+ Code",id:"setupusage-with-net-8-code",level:2},{value:"Installation:",id:"installation",level:3},{value:"Basic TDD Workflow:",id:"basic-tdd-workflow",level:3},{value:"TDD Practices for .NET",id:"tdd-practices-for-net",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"test-driven-development-tdd",children:"Test-Driven Development (TDD)"})}),"\n",(0,i.jsx)(n.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Test-Driven Development (TDD) is a software development methodology where tests are written before the actual implementation code. The process follows a Red-Green-Refactor cycle: write a failing test (Red), implement the minimum code to pass (Green), then refactor for quality while keeping tests passing."}),"\n",(0,i.jsx)(n.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,i.jsx)(n.p,{children:"TDD is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the code is improved so that the tests pass. This is opposed to software development that allows code to be added that is not proven to meet requirements."}),"\n",(0,i.jsx)(n.h2,{id:"tdd-principles-and-process",children:"TDD Principles and Process"}),"\n",(0,i.jsx)(n.h3,{id:"the-red-green-refactor-cycle",children:"The Red-Green-Refactor Cycle:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Red"}),": Write a failing test that defines desired functionality"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Green"}),": Write minimal code to make the test pass"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Refactor"}),": Improve code quality while keeping tests green"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"core-principles",children:"Core Principles:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Write only enough test to fail"}),"\n",(0,i.jsx)(n.li,{children:"Write only enough code to pass the test"}),"\n",(0,i.jsx)(n.li,{children:"Refactor with confidence knowing tests protect against regressions"}),"\n",(0,i.jsx)(n.li,{children:"Tests serve as living documentation"}),"\n",(0,i.jsx)(n.li,{children:"Design emerges from test requirements"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complex Business Logic"}),": Ensures business rules are correctly implemented"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"API Development"}),": Validates endpoints behave as expected"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Legacy Code Refactoring"}),": Provides safety net when changing existing code"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Team Collaboration"}),": Tests serve as living documentation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Regression Prevention"}),": Catches bugs early in development cycle"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design Improvement"}),": Forces consideration of code design and interfaces"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,i.jsx)(n.h3,{id:"use-tdd-when",children:"Use TDD when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Working on complex business logic"}),"\n",(0,i.jsx)(n.li,{children:"Building critical system components"}),"\n",(0,i.jsx)(n.li,{children:"Working in teams where code quality is paramount"}),"\n",(0,i.jsx)(n.li,{children:"Refactoring legacy systems"}),"\n",(0,i.jsx)(n.li,{children:"Building long-term maintainable software"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"consider-alternatives-when",children:"Consider alternatives when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prototyping or proof-of-concept work"}),"\n",(0,i.jsx)(n.li,{children:"Simple CRUD operations with minimal logic"}),"\n",(0,i.jsx)(n.li,{children:"Working with rapidly changing requirements"}),"\n",(0,i.jsx)(n.li,{children:"Time constraints are extremely tight"}),"\n",(0,i.jsx)(n.li,{children:"Team lacks TDD experience and training time"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"market-alternatives--proscons",children:"Market Alternatives & Pros/Cons"}),"\n",(0,i.jsx)(n.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Behavior-Driven Development (BDD)"}),": SpecFlow, Cucumber"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test-After Development"}),": Traditional approach"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Property-Based Testing"}),": FsCheck"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mutation Testing"}),": Stryker.NET"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pros",children:"Pros:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Higher code quality and fewer bugs"}),"\n",(0,i.jsx)(n.li,{children:"Better code design through testability focus"}),"\n",(0,i.jsx)(n.li,{children:"Living documentation through tests"}),"\n",(0,i.jsx)(n.li,{children:"Confidence in refactoring"}),"\n",(0,i.jsx)(n.li,{children:"Faster debugging and development cycles"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"cons",children:"Cons:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Initial learning curve and slower start"}),"\n",(0,i.jsx)(n.li,{children:"More code to write and maintain"}),"\n",(0,i.jsx)(n.li,{children:"Can lead to over-testing trivial code"}),"\n",(0,i.jsx)(n.li,{children:"May not suit all development contexts"}),"\n",(0,i.jsx)(n.li,{children:"Requires discipline and team buy-in"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"benefits-of-tdd-in-net-development",children:"Benefits of TDD in .NET Development"}),"\n",(0,i.jsx)(n.h3,{id:"code-quality-benefits",children:"Code Quality Benefits:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Higher test coverage by design"}),"\n",(0,i.jsx)(n.li,{children:"Better code design and architecture"}),"\n",(0,i.jsx)(n.li,{children:"Reduced debugging time"}),"\n",(0,i.jsx)(n.li,{children:"Fewer production defects"}),"\n",(0,i.jsx)(n.li,{children:"Self-documenting code through tests"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"development-process-benefits",children:"Development Process Benefits:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Faster feedback loop"}),"\n",(0,i.jsx)(n.li,{children:"Confidence in refactoring"}),"\n",(0,i.jsx)(n.li,{children:"Clear requirements understanding"}),"\n",(0,i.jsx)(n.li,{children:"Incremental development approach"}),"\n",(0,i.jsx)(n.li,{children:"Better team collaboration"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"long-term-benefits",children:"Long-term Benefits:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maintainable codebase"}),"\n",(0,i.jsx)(n.li,{children:"Easier feature additions"}),"\n",(0,i.jsx)(n.li,{children:"Reduced technical debt"}),"\n",(0,i.jsx)(n.li,{children:"Better system design"}),"\n",(0,i.jsx)(n.li,{children:"Improved developer productivity"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tdd-best-practices-for-net",children:"TDD Best Practices for .NET"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Start Small"}),": Begin with simple, focused tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test Behavior, Not Implementation"}),": Focus on what the code should do"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Descriptive Test Names"}),": Tests should clearly communicate intent"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Keep Tests Independent"}),": Each test should run in isolation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Follow SOLID Principles"}),": TDD naturally leads to better design"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mock External Dependencies"}),": Use frameworks like Moq for isolation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Refactor Regularly"}),": Improve code quality continuously"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Write Tests First"}),": Resist the urge to write code before tests"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-tdd-challenges-and-solutions",children:"Common TDD Challenges and Solutions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Slow test execution\r\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Use unit tests for TDD, integration tests for verification"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Over-testing or testing implementation details\r\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Focus on public interfaces and behavior"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Difficulty writing tests for complex scenarios\r\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Break down complex problems into smaller, testable units"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Team resistance to TDD\r\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Start with critical components, demonstrate value, provide training"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Legacy code without tests\r\n",(0,i.jsx)(n.strong,{children:"Solution"}),": Use characterization tests, gradually introduce TDD for new features"]}),"\n",(0,i.jsx)(n.p,{children:"TDD is particularly effective in .NET development when combined with:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dependency injection for testable designs"}),"\n",(0,i.jsx)(n.li,{children:"SOLID principles for maintainable code"}),"\n",(0,i.jsx)(n.li,{children:"Clean architecture patterns"}),"\n",(0,i.jsx)(n.li,{children:"Continuous integration for automated testing"}),"\n",(0,i.jsx)(n.li,{children:"Code review practices that emphasize test quality"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The investment in TDD pays dividends through reduced bugs, improved design, and increased developer confidence in making changes to the codebase."}),"\n",(0,i.jsx)(n.h2,{id:"setupusage-with-net-8-code",children:"Setup/Usage with .NET 8+ Code"}),"\n",(0,i.jsx)(n.h3,{id:"installation",children:"Installation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"dotnet add package xunit\r\ndotnet add package xunit.runner.visualstudio\r\ndotnet add package Microsoft.NET.Test.Sdk\r\ndotnet add package Moq\r\ndotnet add package FluentAssertions\n"})}),"\n",(0,i.jsx)(n.h3,{id:"basic-tdd-workflow",children:"Basic TDD Workflow:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// 1. RED: Write failing test first\r\n[Fact]\r\npublic void CalculateTotal_ShouldReturnCorrectSum_WhenValidItemsProvided()\r\n{\r\n    // Arrange\r\n    var calculator = new OrderCalculator();\r\n    var items = new List<OrderItem>\r\n    {\r\n        new() { Price = 10.00m, Quantity = 2 },\r\n        new() { Price = 5.50m, Quantity = 1 }\r\n    };\r\n\r\n    // Act\r\n    var result = calculator.CalculateTotal(items);\r\n\r\n    // Assert\r\n    result.Should().Be(25.50m);\r\n}\r\n\r\n// 2. GREEN: Implement minimum code to pass\r\npublic class OrderCalculator\r\n{\r\n    public decimal CalculateTotal(List<OrderItem> items)\r\n    {\r\n        return items.Sum(i => i.Price * i.Quantity);\r\n    }\r\n}\r\n\r\n// 3. REFACTOR: Improve code quality\r\npublic class OrderCalculator\r\n{\r\n    public decimal CalculateTotal(IEnumerable<OrderItem> items)\r\n    {\r\n        if (items == null) throw new ArgumentNullException(nameof(items));\r\n\r\n        return items\r\n            .Where(item => item != null)\r\n            .Sum(item => item.Price * item.Quantity);\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tdd-practices-for-net",children:"TDD Practices for .NET"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Example: TDD for Hotel Room Availability Service\r\n\r\n// Step 1: RED - Write failing test\r\n[Test]\r\npublic void IsRoomAvailable_WhenRoomExists_ReturnsTrue()\r\n{\r\n    // Arrange\r\n    var roomService = new RoomService();\r\n\r\n    // Act\r\n    var result = roomService.IsRoomAvailable(101);\r\n\r\n    // Assert\r\n    Assert.That(result, Is.True);\r\n}\r\n\r\n// This test fails because RoomService doesn't exist yet\r\n\r\n// Step 2: GREEN - Write minimal code to pass\r\npublic class RoomService\r\n{\r\n    public bool IsRoomAvailable(int roomId)\r\n    {\r\n        return true; // Simplest implementation to pass the test\r\n    }\r\n}\r\n\r\n// Step 3: REFACTOR - Add more tests and improve implementation\r\n[Test]\r\npublic void IsRoomAvailable_WhenRoomDoesNotExist_ReturnsFalse()\r\n{\r\n    // Arrange\r\n    var roomService = new RoomService();\r\n\r\n    // Act\r\n    var result = roomService.IsRoomAvailable(999);\r\n\r\n    // Assert\r\n    Assert.That(result, Is.False);\r\n}\r\n\r\n// Now we need to improve the implementation\r\npublic class RoomService\r\n{\r\n    private readonly List<int> _availableRooms = new() { 101, 102, 103 };\r\n\r\n    public bool IsRoomAvailable(int roomId)\r\n    {\r\n        return _availableRooms.Contains(roomId);\r\n    }\r\n}\r\n\r\n// Continue with more tests and refinements\r\n[Test]\r\npublic void IsRoomAvailable_WhenRoomIsBooked_ReturnsFalse()\r\n{\r\n    // Arrange\r\n    var roomService = new RoomService();\r\n    roomService.BookRoom(101);\r\n\r\n    // Act\r\n    var result = roomService.IsRoomAvailable(101);\r\n\r\n    // Assert\r\n    Assert.That(result, Is.False);\r\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Models/OrderItem.cs\r\npublic class OrderItem\r\n{\r\n    public string Name { get; set; } = string.Empty;\r\n    public decimal Price { get; set; }\r\n    public int Quantity { get; set; }\r\n    public decimal Discount { get; set; }\r\n}\r\n\r\n// Services/IOrderService.cs\r\npublic interface IOrderService\r\n{\r\n    Task<Order> CreateOrderAsync(List<OrderItem> items, string customerId);\r\n    decimal CalculateDiscount(decimal subtotal, string customerTier);\r\n}\r\n\r\n// Tests/OrderServiceTests.cs\r\nusing Xunit;\r\nusing Moq;\r\nusing FluentAssertions;\r\n\r\npublic class OrderServiceTests\r\n{\r\n    private readonly Mock<ICustomerRepository> _customerRepositoryMock;\r\n    private readonly Mock<IOrderRepository> _orderRepositoryMock;\r\n    private readonly OrderService _orderService;\r\n\r\n    public OrderServiceTests()\r\n    {\r\n        _customerRepositoryMock = new Mock<ICustomerRepository>();\r\n        _orderRepositoryMock = new Mock<IOrderRepository>();\r\n        _orderService = new OrderService(_customerRepositoryMock.Object, _orderRepositoryMock.Object);\r\n    }\r\n\r\n    [Fact]\r\n    public async Task CreateOrderAsync_ShouldCreateOrder_WhenValidItemsProvided()\r\n    {\r\n        // Arrange\r\n        var customerId = "CUST001";\r\n        var items = new List<OrderItem>\r\n        {\r\n            new() { Name = "Product A", Price = 100m, Quantity = 2, Discount = 0 },\r\n            new() { Name = "Product B", Price = 50m, Quantity = 1, Discount = 10m }\r\n        };\r\n\r\n        _customerRepositoryMock\r\n            .Setup(x => x.GetCustomerTierAsync(customerId))\r\n            .ReturnsAsync("Gold");\r\n\r\n        _orderRepositoryMock\r\n            .Setup(x => x.SaveOrderAsync(It.IsAny<Order>()))\r\n            .ReturnsAsync((Order order) => { order.Id = "ORDER001"; return order; });\r\n\r\n        // Act\r\n        var result = await _orderService.CreateOrderAsync(items, customerId);\r\n\r\n        // Assert\r\n        result.Should().NotBeNull();\r\n        result.CustomerId.Should().Be(customerId);\r\n        result.Items.Should().HaveCount(2);\r\n        result.Subtotal.Should().Be(240m); // (100*2) + (50*1) = 250, minus 10 discount\r\n        result.Total.Should().BeLessThan(result.Subtotal); // Gold tier discount applied\r\n    }\r\n\r\n    [Theory]\r\n    [InlineData(100, "Bronze", 100)]\r\n    [InlineData(100, "Silver", 95)]\r\n    [InlineData(100, "Gold", 90)]\r\n    [InlineData(100, "Platinum", 85)]\r\n    public void CalculateDiscount_ShouldReturnCorrectAmount_ForDifferentCustomerTiers(\r\n        decimal subtotal, string tier, decimal expected)\r\n    {\r\n        // Act\r\n        var result = _orderService.CalculateDiscount(subtotal, tier);\r\n\r\n        // Assert\r\n        result.Should().Be(expected);\r\n    }\r\n\r\n    [Fact]\r\n    public async Task CreateOrderAsync_ShouldThrowException_WhenCustomerNotFound()\r\n    {\r\n        // Arrange\r\n        var customerId = "INVALID";\r\n        var items = new List<OrderItem> { new() { Name = "Test", Price = 10, Quantity = 1 } };\r\n\r\n        _customerRepositoryMock\r\n            .Setup(x => x.GetCustomerTierAsync(customerId))\r\n            .ThrowsAsync(new CustomerNotFoundException(customerId));\r\n\r\n        // Act & Assert\r\n        await _orderService.Invoking(x => x.CreateOrderAsync(items, customerId))\r\n            .Should().ThrowAsync<CustomerNotFoundException>()\r\n            .WithMessage($"Customer {customerId} not found");\r\n    }\r\n}\r\n\r\n// Services/OrderService.cs - Implementation\r\npublic class OrderService : IOrderService\r\n{\r\n    private readonly ICustomerRepository _customerRepository;\r\n    private readonly IOrderRepository _orderRepository;\r\n\r\n    public OrderService(ICustomerRepository customerRepository, IOrderRepository orderRepository)\r\n    {\r\n        _customerRepository = customerRepository;\r\n        _orderRepository = orderRepository;\r\n    }\r\n\r\n    public async Task<Order> CreateOrderAsync(List<OrderItem> items, string customerId)\r\n    {\r\n        if (items == null || !items.Any())\r\n            throw new ArgumentException("Order must contain at least one item");\r\n\r\n        var customerTier = await _customerRepository.GetCustomerTierAsync(customerId);\r\n\r\n        var subtotal = items.Sum(i => (i.Price * i.Quantity) - i.Discount);\r\n        var total = CalculateDiscount(subtotal, customerTier);\r\n\r\n        var order = new Order\r\n        {\r\n            CustomerId = customerId,\r\n            Items = items,\r\n            Subtotal = subtotal,\r\n            Total = total,\r\n            CreatedAt = DateTime.UtcNow\r\n        };\r\n\r\n        return await _orderRepository.SaveOrderAsync(order);\r\n    }\r\n\r\n    public decimal CalculateDiscount(decimal subtotal, string customerTier)\r\n    {\r\n        var discountPercentage = customerTier switch\r\n        {\r\n            "Bronze" => 0m,\r\n            "Silver" => 0.05m,\r\n            "Gold" => 0.10m,\r\n            "Platinum" => 0.15m,\r\n            _ => 0m\r\n        };\r\n\r\n        return subtotal * (1 - discountPercentage);\r\n    }\r\n}\r\n\r\n// Project file structure for TDD\r\n// HotelManagement.Tests.csproj\r\n<Project Sdk="Microsoft.NET.Sdk">\r\n  <PropertyGroup>\r\n    <TargetFramework>net8.0</TargetFramework>\r\n    <IsPackable>false</IsPackable>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0" />\r\n    <PackageReference Include="xunit" Version="2.4.2" />\r\n    <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5" />\r\n    <PackageReference Include="Moq" Version="4.20.69" />\r\n    <PackageReference Include="FluentAssertions" Version="6.12.0" />\r\n  </ItemGroup>\r\n\r\n  <ItemGroup>\r\n    <ProjectReference Include="..\\HotelManagement.Core\\HotelManagement.Core.csproj" />\r\n  </ItemGroup>\r\n</Project>\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);