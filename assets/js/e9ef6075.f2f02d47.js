"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[9002],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var i=r(6540);const t={},o=i.createContext(t);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:n},e.children)}},8878:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Topics/PerformanceAndScalability/PerformanceOptimization","title":"Performance Optimization","description":"Short Introduction","source":"@site/docs/Topics/06_PerformanceAndScalability/28_PerformanceOptimization.md","sourceDirName":"Topics/06_PerformanceAndScalability","slug":"/Topics/PerformanceAndScalability/performance_optimization","permalink":"/docusaurus_dotnet_overview/docs/Topics/PerformanceAndScalability/performance_optimization","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"dotnet","permalink":"/docusaurus_dotnet_overview/docs/tags/dotnet"},{"inline":true,"label":"performance","permalink":"/docusaurus_dotnet_overview/docs/tags/performance"},{"inline":true,"label":"optimization","permalink":"/docusaurus_dotnet_overview/docs/tags/optimization"}],"version":"current","sidebarPosition":28,"frontMatter":{"slug":"performance_optimization","title":"Performance Optimization","tags":["dotnet","performance","optimization"]},"sidebar":"tutorialSidebar","previous":{"title":"Background Services","permalink":"/docusaurus_dotnet_overview/docs/Topics/PerformanceAndScalability/background_services"},"next":{"title":"Memory Management","permalink":"/docusaurus_dotnet_overview/docs/Topics/PerformanceAndScalability/memory_management"}}');var t=r(4848),o=r(8453);const s={slug:"performance_optimization",title:"Performance Optimization",tags:["dotnet","performance","optimization"]},a="Performance Optimization",l={},c=[{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition:",id:"official-definition",level:2},{value:"Setup/Usage",id:"setupusage",level:2},{value:"Profiling Tools Setup:",id:"profiling-tools-setup",level:3},{value:"AOT Publishing:",id:"aot-publishing",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"When to Use:",id:"when-to-use",level:3},{value:"When Not to Use:",id:"when-not-to-use",level:3},{value:"Alternatives and Trade-offs",id:"alternatives-and-trade-offs",level:2},{value:"Alternatives:",id:"alternatives",level:3},{value:"Trade-offs:",id:"trade-offs",level:3},{value:"Sample Code and Commands",id:"sample-code-and-commands",level:2},{value:"BenchmarkDotNet Example:",id:"benchmarkdotnet-example",level:3},{value:"ThreadPool Tuning:",id:"threadpool-tuning",level:3},{value:"High-Performance HTTP Client:",id:"high-performance-http-client",level:3},{value:"Memory-Efficient Collections:",id:"memory-efficient-collections",level:3},{value:"Performance Commands:",id:"performance-commands",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"performance-optimization",children:"Performance Optimization"})}),"\n",(0,t.jsx)(n.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Performance optimization in .NET Core involves analyzing, measuring, and improving application speed, throughput, and resource utilization. It encompasses profiling, JIT/AOT compilation strategies, threading optimizations, and runtime tuning."}),"\n",(0,t.jsx)(n.h2,{id:"official-definition",children:"Official Definition:"}),"\n",(0,t.jsx)(n.p,{children:"Performance optimization is the systematic process of making .NET applications run faster and use resources more efficiently through code improvements, configuration tuning, and runtime optimizations."}),"\n",(0,t.jsx)(n.h2,{id:"setupusage",children:"Setup/Usage"}),"\n",(0,t.jsx)(n.h3,{id:"profiling-tools-setup",children:"Profiling Tools Setup:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add to .csproj for profiling --\x3e\r\n<PackageReference Include="Microsoft.Diagnostics.Tracing.TraceEvent" Version="3.0.2" />\r\n<PackageReference Include="BenchmarkDotNet" Version="0.13.8" />\n'})}),"\n",(0,t.jsx)(n.h3,{id:"aot-publishing",children:"AOT Publishing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Enable AOT in .csproj --\x3e\r\n<PropertyGroup>\r\n    <PublishAot>true</PublishAot>\r\n    <InvariantGlobalization>true</InvariantGlobalization>\r\n</PropertyGroup>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High-traffic web applications"})," requiring low latency"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Microservices"})," with strict SLA requirements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-time systems"})," needing predictable response times"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource-constrained environments"})," (IoT, edge computing)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost optimization"})," in cloud deployments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch processing"})," applications handling large datasets"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use",children:"When to Use:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Performance bottlenecks are identified through profiling"}),"\n",(0,t.jsx)(n.li,{children:"Application doesn't meet performance requirements"}),"\n",(0,t.jsx)(n.li,{children:"Resource costs are high due to inefficiency"}),"\n",(0,t.jsx)(n.li,{children:"User experience is impacted by slow response times"}),"\n",(0,t.jsx)(n.li,{children:"Scaling requirements demand optimization"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"when-not-to-use",children:"When Not to Use:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Premature optimization without measurement"}),"\n",(0,t.jsx)(n.li,{children:"Development time outweighs performance benefits"}),"\n",(0,t.jsx)(n.li,{children:"Simple applications with minimal load"}),"\n",(0,t.jsx)(n.li,{children:"Temporary or prototype applications"}),"\n",(0,t.jsx)(n.li,{children:"When optimization adds significant complexity"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"alternatives-and-trade-offs",children:"Alternatives and Trade-offs"}),"\n",(0,t.jsx)(n.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Horizontal scaling instead of optimization"}),"\n",(0,t.jsx)(n.li,{children:"Caching layers to mask performance issues"}),"\n",(0,t.jsx)(n.li,{children:"CDN for content delivery optimization"}),"\n",(0,t.jsx)(n.li,{children:"Database optimization and indexing"}),"\n",(0,t.jsx)(n.li,{children:"Infrastructure upgrades (faster CPUs, more RAM)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"trade-offs",children:"Trade-offs:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Development time vs performance gains"}),"\n",(0,t.jsx)(n.li,{children:"Code complexity vs execution speed"}),"\n",(0,t.jsx)(n.li,{children:"Memory usage vs CPU usage"}),"\n",(0,t.jsx)(n.li,{children:"Startup time vs runtime performance (AOT vs JIT)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"sample-code-and-commands",children:"Sample Code and Commands"}),"\n",(0,t.jsx)(n.h3,{id:"benchmarkdotnet-example",children:"BenchmarkDotNet Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\n\r\n[MemoryDiagnoser]\r\n[SimpleJob(BenchmarkDotNet.Jobs.RuntimeMoniker.Net80)]\r\npublic class StringConcatenationBenchmark\r\n{\r\n    private readonly string[] _strings = Enumerable.Range(0, 1000)\r\n        .Select(i => $"String_{i}")\r\n        .ToArray();\r\n\r\n    [Benchmark]\r\n    public string UsingStringConcatenation()\r\n    {\r\n        string result = "";\r\n        foreach (var str in _strings)\r\n        {\r\n            result += str;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    [Benchmark]\r\n    public string UsingStringBuilder()\r\n    {\r\n        var sb = new StringBuilder();\r\n        foreach (var str in _strings)\r\n        {\r\n            sb.Append(str);\r\n        }\r\n        return sb.ToString();\r\n    }\r\n\r\n    [Benchmark]\r\n    public string UsingStringJoin()\r\n    {\r\n        return string.Join("", _strings);\r\n    }\r\n}\r\n\r\n// Program.cs\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        BenchmarkRunner.Run<StringConcatenationBenchmark>();\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"threadpool-tuning",children:"ThreadPool Tuning:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Program.cs - Configure ThreadPool\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Configure ThreadPool for high-throughput scenarios\r\nThreadPool.SetMinThreads(\r\n    workerThreads: Environment.ProcessorCount * 4,\r\n    completionPortThreads: Environment.ProcessorCount * 4\r\n);\r\n\r\n// Configure Kestrel for performance\r\nbuilder.Services.Configure<KestrelServerOptions>(options =>\r\n{\r\n    options.Limits.MaxConcurrentConnections = 1000;\r\n    options.Limits.MaxConcurrentUpgradedConnections = 1000;\r\n    options.Limits.MaxRequestBodySize = 10 * 1024 * 1024; // 10MB\r\n    options.Limits.MinRequestBodyDataRate = new MinDataRate(100, TimeSpan.FromSeconds(10));\r\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"high-performance-http-client",children:"High-Performance HTTP Client:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Efficient HttpClient usage\r\npublic class OptimizedHttpService\r\n{\r\n    private static readonly HttpClient _httpClient = new HttpClient(new SocketsHttpHandler\r\n    {\r\n        PooledConnectionLifetime = TimeSpan.FromMinutes(15),\r\n        MaxConnectionsPerServer = 10\r\n    });\r\n\r\n    static OptimizedHttpService()\r\n    {\r\n        _httpClient.DefaultRequestHeaders.Connection.Add("keep-alive");\r\n    }\r\n\r\n    public async Task<T> GetAsync<T>(string url)\r\n    {\r\n        using var response = await _httpClient.GetAsync(url);\r\n\r\n        // Use System.Text.Json for better performance\r\n        var jsonStream = await response.Content.ReadAsStreamAsync();\r\n        return await JsonSerializer.DeserializeAsync<T>(jsonStream);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"memory-efficient-collections",children:"Memory-Efficient Collections:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Use Span<T> and Memory<T> for high-performance scenarios\r\npublic class HighPerformanceProcessor\r\n{\r\n    public void ProcessData(ReadOnlySpan<byte> data)\r\n    {\r\n        // Process data without allocations\r\n        for (int i = 0; i < data.Length; i++)\r\n        {\r\n            var value = data[i];\r\n            // Process value\r\n        }\r\n    }\r\n\r\n    public async Task<int> ProcessFileAsync(string filePath)\r\n    {\r\n        // Use Memory<T> for async operations\r\n        using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);\r\n        var buffer = new byte[4096];\r\n        var memory = buffer.AsMemory();\r\n\r\n        int totalBytes = 0;\r\n        int bytesRead;\r\n\r\n        while ((bytesRead = await fileStream.ReadAsync(memory)) > 0)\r\n        {\r\n            totalBytes += bytesRead;\r\n            ProcessData(memory.Span[..bytesRead]);\r\n        }\r\n\r\n        return totalBytes;\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"performance-commands",children:"Performance Commands:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Build with AOT\r\ndotnet publish -c Release -r win-x64 --self-contained\r\n\r\n# Profile with dotnet-trace\r\ndotnet tool install --global dotnet-trace\r\ndotnet trace collect --process-id <PID> --providers Microsoft-DotNETCore-SampleProfiler\r\n\r\n# Analyze memory usage\r\ndotnet tool install --global dotnet-dump\r\ndotnet dump collect --process-id <PID>\r\n\r\n# Monitor performance counters\r\ndotnet tool install --global dotnet-counters\r\ndotnet counters monitor --process-id <PID> System.Runtime\n"})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);