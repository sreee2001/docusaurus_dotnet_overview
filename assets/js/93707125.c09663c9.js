"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[9365],{3332:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Topics/Microservices/APIGateway","title":"APIGateway","description":"45. API Gateway (YARP, Azure API Management)","source":"@site/docs/Topics/10_Microservices/45_APIGateway.md","sourceDirName":"Topics/10_Microservices","slug":"/Topics/Microservices/APIGateway","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/APIGateway","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":45,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"MicroservicesArchitecture","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/MicroservicesArchitecture"},"next":{"title":"ServiceDiscovery","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/ServiceDiscovery"}}');var i=r(4848),o=r(8453);const a={},s=void 0,l={},c=[{value:"45. API Gateway (YARP, Azure API Management)",id:"45-api-gateway-yarp-azure-api-management",level:2},{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition",id:"official-definition",level:2},{value:"Setup/Usage with .NET 8+ Code",id:"setupusage-with-net-8-code",level:2},{value:"Use Cases",id:"use-cases",level:3},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Market Alternatives &amp; Pros/Cons",id:"market-alternatives--proscons",level:3},{value:"Alternatives:",id:"alternatives",level:3},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Complete Runnable Sample",id:"complete-runnable-sample",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"45-api-gateway-yarp-azure-api-management",children:"45. API Gateway (YARP, Azure API Management)"}),"\n",(0,i.jsx)(n.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,i.jsx)(n.p,{children:"An API Gateway is a server that acts as an API front-end, receiving API requests, enforcing throttling and security policies, passing requests to the back-end service, and then passing the response back to the requester. YARP (Yet Another Reverse Proxy) is Microsoft's .NET-based reverse proxy toolkit, while Azure API Management provides a comprehensive managed API gateway solution."}),"\n",(0,i.jsx)(n.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,i.jsx)(n.p,{children:"An API Gateway is an API management tool that sits between a client and a collection of backend services. It acts as a reverse proxy to accept all API calls, aggregate the various services required to fulfill them, and return the appropriate result. YARP is a library to help create reverse proxy servers that are high-performance, production-ready, and highly customizable."}),"\n",(0,i.jsx)(n.h2,{id:"setupusage-with-net-8-code",children:"Setup/Usage with .NET 8+ Code"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"YARP Implementation:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Install YARP package\r\ndotnet add package Yarp.ReverseProxy\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Program.cs with YARP:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// ApiGateway/Program.cs\r\nusing Yarp.ReverseProxy.Configuration;\r\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add YARP\r\nbuilder.Services.AddReverseProxy()\r\n    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));\r\n\r\n// Add authentication\r\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n    .AddJwtBearer(options =>\r\n    {\r\n        options.Authority = builder.Configuration["Auth:Authority"];\r\n        options.Audience = builder.Configuration["Auth:Audience"];\r\n    });\r\n\r\nbuilder.Services.AddAuthorization(options =>\r\n{\r\n    options.AddPolicy("RequireAdmin", policy => policy.RequireClaim("role", "admin"));\r\n    options.AddPolicy("RequireUser", policy => policy.RequireAuthenticatedUser());\r\n});\r\n\r\n// Add rate limiting\r\nbuilder.Services.AddRateLimiter(options =>\r\n{\r\n    options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(context =>\r\n        RateLimitPartition.GetFixedWindowLimiter(\r\n            partitionKey: context.User?.Identity?.Name ?? context.Request.Headers.Host.ToString(),\r\n            factory: partition => new FixedWindowRateLimiterOptions\r\n            {\r\n                AutoReplenishment = true,\r\n                PermitLimit = 100,\r\n                Window = TimeSpan.FromMinutes(1)\r\n            }));\r\n});\r\n\r\n// Add CORS\r\nbuilder.Services.AddCors(options =>\r\n{\r\n    options.AddPolicy("AllowAll", policy =>\r\n    {\r\n        policy.AllowAnyOrigin()\r\n              .AllowAnyMethod()\r\n              .AllowAnyHeader();\r\n    });\r\n});\r\n\r\nvar app = builder.Build();\r\n\r\n// Configure pipeline\r\napp.UseCors("AllowAll");\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\napp.UseRateLimiter();\r\n\r\n// Map reverse proxy\r\napp.MapReverseProxy();\r\n\r\napp.Run();\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"YARP Configuration (appsettings.json):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\r\n  "Logging": {\r\n    "LogLevel": {\r\n      "Default": "Information",\r\n      "Yarp": "Warning"\r\n    }\r\n  },\r\n  "ReverseProxy": {\r\n    "Routes": {\r\n      "booking-route": {\r\n        "ClusterId": "booking-cluster",\r\n        "Match": {\r\n          "Path": "/api/bookings/{**catch-all}"\r\n        },\r\n        "Transforms": [\r\n          {\r\n            "PathPattern": "/api/bookings/{**catch-all}"\r\n          },\r\n          {\r\n            "RequestHeader": "X-Forwarded-Host",\r\n            "Set": "{OriginalHost}"\r\n          }\r\n        ],\r\n        "AuthorizationPolicy": "RequireUser"\r\n      },\r\n      "room-route": {\r\n        "ClusterId": "room-cluster",\r\n        "Match": {\r\n          "Path": "/api/rooms/{**catch-all}"\r\n        },\r\n        "Transforms": [\r\n          {\r\n            "PathPattern": "/api/rooms/{**catch-all}"\r\n          }\r\n        ]\r\n      },\r\n      "admin-route": {\r\n        "ClusterId": "admin-cluster",\r\n        "Match": {\r\n          "Path": "/api/admin/{**catch-all}"\r\n        },\r\n        "AuthorizationPolicy": "RequireAdmin",\r\n        "RateLimiterPolicy": "AdminPolicy"\r\n      }\r\n    },\r\n    "Clusters": {\r\n      "booking-cluster": {\r\n        "Destinations": {\r\n          "destination1": {\r\n            "Address": "http://booking-service:8080/"\r\n          }\r\n        },\r\n        "HealthCheck": {\r\n          "Active": {\r\n            "Enabled": "true",\r\n            "Interval": "00:00:30",\r\n            "Timeout": "00:00:05",\r\n            "Policy": "ConsecutiveFailures",\r\n            "Path": "/health"\r\n          }\r\n        },\r\n        "LoadBalancingPolicy": "RoundRobin"\r\n      },\r\n      "room-cluster": {\r\n        "Destinations": {\r\n          "destination1": {\r\n            "Address": "http://room-service:8080/"\r\n          },\r\n          "destination2": {\r\n            "Address": "http://room-service-2:8080/"\r\n          }\r\n        },\r\n        "HealthCheck": {\r\n          "Active": {\r\n            "Enabled": "true",\r\n            "Interval": "00:00:30",\r\n            "Timeout": "00:00:05",\r\n            "Policy": "ConsecutiveFailures",\r\n            "Path": "/health"\r\n          }\r\n        },\r\n        "LoadBalancingPolicy": "LeastRequests"\r\n      },\r\n      "admin-cluster": {\r\n        "Destinations": {\r\n          "destination1": {\r\n            "Address": "http://admin-service:8080/"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Custom YARP Middleware:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Middleware/ApiGatewayMiddleware.cs\r\npublic class ApiGatewayMiddleware\r\n{\r\n    private readonly RequestDelegate _next;\r\n    private readonly ILogger<ApiGatewayMiddleware> _logger;\r\n\r\n    public ApiGatewayMiddleware(RequestDelegate next, ILogger<ApiGatewayMiddleware> logger)\r\n    {\r\n        _next = next;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task InvokeAsync(HttpContext context)\r\n    {\r\n        // Add correlation ID\r\n        if (!context.Request.Headers.ContainsKey("X-Correlation-ID"))\r\n        {\r\n            context.Request.Headers.Add("X-Correlation-ID", Guid.NewGuid().ToString());\r\n        }\r\n\r\n        // Log request\r\n        _logger.LogInformation("Gateway request: {Method} {Path} from {RemoteIp}",\r\n            context.Request.Method,\r\n            context.Request.Path,\r\n            context.Connection.RemoteIpAddress);\r\n\r\n        // Add request timestamp\r\n        context.Request.Headers.Add("X-Gateway-Timestamp", DateTimeOffset.UtcNow.ToString("O"));\r\n\r\n        await _next(context);\r\n\r\n        // Log response\r\n        _logger.LogInformation("Gateway response: {StatusCode} for {Method} {Path}",\r\n            context.Response.StatusCode,\r\n            context.Request.Method,\r\n            context.Request.Path);\r\n    }\r\n}\r\n\r\n// Transforms/CustomTransforms.cs\r\npublic class AddCustomHeaderTransform : ITransformProvider\r\n{\r\n    public void ValidateRoute(RouteConfig route, IList<Exception> errors)\r\n    {\r\n        // Validation logic if needed\r\n    }\r\n\r\n    public void ValidateCluster(ClusterConfig cluster, IList<Exception> errors)\r\n    {\r\n        // Validation logic if needed\r\n    }\r\n\r\n    public void Apply(TransformBuilderContext context)\r\n    {\r\n        // Add custom transforms\r\n        context.AddRequestTransform(transformContext =>\r\n        {\r\n            transformContext.ProxyRequest.Headers.Add("X-Gateway-Version", "1.0");\r\n            transformContext.ProxyRequest.Headers.Add("X-Request-ID", Guid.NewGuid().ToString());\r\n            return ValueTask.CompletedTask;\r\n        });\r\n\r\n        context.AddResponseTransform(transformContext =>\r\n        {\r\n            transformContext.HttpContext.Response.Headers.Add("X-Powered-By", "YARP Gateway");\r\n            return ValueTask.CompletedTask;\r\n        });\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Azure API Management Integration:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// For comparison - Azure API Management would be configured via ARM template\r\n// azuredeploy.json (excerpt)\r\n{\r\n  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",\r\n  "contentVersion": "1.0.0.0",\r\n  "parameters": {\r\n    "apiManagementServiceName": {\r\n      "type": "string",\r\n      "defaultValue": "hotel-management-apim"\r\n    }\r\n  },\r\n  "resources": [\r\n    {\r\n      "type": "Microsoft.ApiManagement/service",\r\n      "apiVersion": "2021-08-01",\r\n      "name": "[parameters(\'apiManagementServiceName\')]",\r\n      "location": "[resourceGroup().location]",\r\n      "sku": {\r\n        "name": "Developer",\r\n        "capacity": 1\r\n      },\r\n      "properties": {\r\n        "publisherEmail": "admin@hotelmanagement.com",\r\n        "publisherName": "Hotel Management",\r\n        "notificationSenderEmail": "apimgmt-noreply@mail.windowsazure.com"\r\n      }\r\n    },\r\n    {\r\n      "type": "Microsoft.ApiManagement/service/apis",\r\n      "apiVersion": "2021-08-01",\r\n      "name": "[concat(parameters(\'apiManagementServiceName\'), \'/booking-api\')]",\r\n      "dependsOn": [\r\n        "[resourceId(\'Microsoft.ApiManagement/service\', parameters(\'apiManagementServiceName\'))]"\r\n      ],\r\n      "properties": {\r\n        "displayName": "Booking API",\r\n        "apiRevision": "1",\r\n        "subscriptionRequired": true,\r\n        "serviceUrl": "http://booking-service:8080",\r\n        "path": "bookings",\r\n        "protocols": ["https"]\r\n      }\r\n    }\r\n  ]\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Entry Point"}),": Centralized access to multiple microservices"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cross-Cutting Concerns"}),": Authentication, logging, rate limiting, CORS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"API Versioning"}),": Route requests to different API versions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Load Balancing"}),": Distribute requests across multiple service instances"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Protocol Translation"}),": Convert between different protocols (HTTP, gRPC)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Request/Response Transformation"}),": Modify requests and responses"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use API Gateway when:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Running microservices architecture"}),"\n",(0,i.jsx)(n.li,{children:"Need centralized authentication and authorization"}),"\n",(0,i.jsx)(n.li,{children:"Require request routing and load balancing"}),"\n",(0,i.jsx)(n.li,{children:"Need to implement cross-cutting concerns"}),"\n",(0,i.jsx)(n.li,{children:"Want to hide internal service complexity from clients"}),"\n",(0,i.jsx)(n.li,{children:"Need API versioning and backwards compatibility"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Consider alternatives when:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Simple monolithic applications"}),"\n",(0,i.jsx)(n.li,{children:"Direct service-to-service communication is preferred"}),"\n",(0,i.jsx)(n.li,{children:"Low latency requirements (additional network hop)"}),"\n",(0,i.jsx)(n.li,{children:"Limited operational complexity tolerance"}),"\n",(0,i.jsx)(n.li,{children:"Small number of services with simple routing needs"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"market-alternatives--proscons",children:"Market Alternatives & Pros/Cons"}),"\n",(0,i.jsx)(n.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Kong"}),": Open-source API gateway with enterprise features"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Istio"}),": Service mesh with gateway capabilities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ambassador"}),": Kubernetes-native API gateway"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"AWS API Gateway"}),": Managed API gateway service"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Traefik"}),": Modern reverse proxy and load balancer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Nginx Plus"}),": Commercial version with API gateway features"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pros",children:"Pros:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Centralized cross-cutting concerns"}),"\n",(0,i.jsx)(n.li,{children:"Single entry point for clients"}),"\n",(0,i.jsx)(n.li,{children:"Built-in load balancing and health checks"}),"\n",(0,i.jsx)(n.li,{children:"Request/response transformation capabilities"}),"\n",(0,i.jsx)(n.li,{children:"Integration with .NET ecosystem (YARP)"}),"\n",(0,i.jsx)(n.li,{children:"Reduced client complexity"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"cons",children:"Cons:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Additional network latency"}),"\n",(0,i.jsx)(n.li,{children:"Single point of failure risk"}),"\n",(0,i.jsx)(n.li,{children:"Operational complexity"}),"\n",(0,i.jsx)(n.li,{children:"Potential bottleneck"}),"\n",(0,i.jsx)(n.li,{children:"Additional infrastructure component to manage"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"complete-runnable-sample",children:"Complete Runnable Sample"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Production-Ready YARP Gateway:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// ApiGateway/Program.cs - Complete implementation\r\nusing Yarp.ReverseProxy.Configuration;\r\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\r\nusing Microsoft.AspNetCore.RateLimiting;\r\nusing System.Threading.RateLimiting;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add services\r\nbuilder.Services.AddReverseProxy()\r\n    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));\r\n\r\n// Add authentication and authorization\r\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n    .AddJwtBearer(options =>\r\n    {\r\n        options.Authority = builder.Configuration["Auth:Authority"];\r\n        options.Audience = builder.Configuration["Auth:Audience"];\r\n        options.RequireHttpsMetadata = !builder.Environment.IsDevelopment();\r\n    });\r\n\r\nbuilder.Services.AddAuthorization(options =>\r\n{\r\n    options.AddPolicy("RequireAdmin", policy =>\r\n        policy.RequireClaim("role", "admin"));\r\n    options.AddPolicy("RequireUser", policy =>\r\n        policy.RequireAuthenticatedUser());\r\n    options.AddPolicy("RequireCustomer", policy =>\r\n        policy.RequireClaim("role", "customer"));\r\n});\r\n\r\n// Add rate limiting with different policies\r\nbuilder.Services.AddRateLimiter(options =>\r\n{\r\n    // Global rate limiter\r\n    options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, string>(context =>\r\n        RateLimitPartition.GetFixedWindowLimiter(\r\n            partitionKey: GetPartitionKey(context),\r\n            factory: partition => new FixedWindowRateLimiterOptions\r\n            {\r\n                AutoReplenishment = true,\r\n                PermitLimit = 1000,\r\n                Window = TimeSpan.FromMinutes(1)\r\n            }));\r\n\r\n    // Admin policy - higher limits\r\n    options.AddPolicy("AdminPolicy", context =>\r\n        RateLimitPartition.GetFixedWindowLimiter(\r\n            partitionKey: GetPartitionKey(context),\r\n            factory: partition => new FixedWindowRateLimiterOptions\r\n            {\r\n                AutoReplenishment = true,\r\n                PermitLimit = 10000,\r\n                Window = TimeSpan.FromMinutes(1)\r\n            }));\r\n\r\n    // Customer policy - standard limits\r\n    options.AddPolicy("CustomerPolicy", context =>\r\n        RateLimitPartition.GetFixedWindowLimiter(\r\n            partitionKey: GetPartitionKey(context),\r\n            factory: partition => new FixedWindowRateLimiterOptions\r\n            {\r\n                AutoReplenishment = true,\r\n                PermitLimit = 100,\r\n                Window = TimeSpan.FromMinutes(1)\r\n            }));\r\n\r\n    options.OnRejected = async (context, token) =>\r\n    {\r\n        context.HttpContext.Response.StatusCode = 429;\r\n        await context.HttpContext.Response.WriteAsync("Rate limit exceeded. Try again later.", token);\r\n    };\r\n});\r\n\r\n// Add CORS\r\nbuilder.Services.AddCors(options =>\r\n{\r\n    options.AddPolicy("HotelManagementCors", policy =>\r\n    {\r\n        policy.WithOrigins(\r\n                builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>() ?? Array.Empty<string>())\r\n              .AllowAnyMethod()\r\n              .AllowAnyHeader()\r\n              .AllowCredentials();\r\n    });\r\n});\r\n\r\n// Add health checks\r\nbuilder.Services.AddHealthChecks();\r\n\r\n// Add custom services\r\nbuilder.Services.AddSingleton<ITransformProvider, AddCustomHeaderTransform>();\r\nbuilder.Services.AddScoped<ApiKeyValidationService>();\r\n\r\nvar app = builder.Build();\r\n\r\n// Configure pipeline\r\nif (app.Environment.IsDevelopment())\r\n{\r\n    app.UseDeveloperExceptionPage();\r\n}\r\nelse\r\n{\r\n    app.UseExceptionHandler("/Error");\r\n    app.UseHsts();\r\n}\r\n\r\napp.UseHttpsRedirection();\r\napp.UseCors("HotelManagementCors");\r\n\r\n// Custom middleware\r\napp.UseMiddleware<ApiGatewayMiddleware>();\r\napp.UseMiddleware<ApiKeyValidationMiddleware>();\r\n\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\napp.UseRateLimiter();\r\n\r\n// Health checks\r\napp.MapHealthChecks("/health");\r\n\r\n// Map reverse proxy\r\napp.MapReverseProxy(proxyPipeline =>\r\n{\r\n    proxyPipeline.Use(async (context, next) =>\r\n    {\r\n        // Custom proxy middleware\r\n        var correlationId = context.Request.Headers["X-Correlation-ID"].FirstOrDefault() ?? Guid.NewGuid().ToString();\r\n        context.Request.Headers["X-Correlation-ID"] = correlationId;\r\n\r\n        await next();\r\n\r\n        context.Response.Headers["X-Correlation-ID"] = correlationId;\r\n    });\r\n});\r\n\r\napp.Run();\r\n\r\n// Helper method for rate limiting partition key\r\nstatic string GetPartitionKey(HttpContext context)\r\n{\r\n    return context.User?.Identity?.Name ??\r\n           context.Request.Headers["X-API-Key"].FirstOrDefault() ??\r\n           context.Connection.RemoteIpAddress?.ToString() ??\r\n           "anonymous";\r\n}\r\n\r\n// Services/ApiKeyValidationService.cs\r\npublic class ApiKeyValidationService\r\n{\r\n    private readonly IConfiguration _configuration;\r\n    private readonly ILogger<ApiKeyValidationService> _logger;\r\n    private readonly Dictionary<string, ApiKeyInfo> _validApiKeys;\r\n\r\n    public ApiKeyValidationService(IConfiguration configuration, ILogger<ApiKeyValidationService> logger)\r\n    {\r\n        _configuration = configuration;\r\n        _logger = logger;\r\n        _validApiKeys = LoadApiKeysFromConfiguration();\r\n    }\r\n\r\n    public bool IsValidApiKey(string apiKey, out ApiKeyInfo? keyInfo)\r\n    {\r\n        keyInfo = null;\r\n        if (string.IsNullOrEmpty(apiKey))\r\n            return false;\r\n\r\n        if (_validApiKeys.TryGetValue(apiKey, out keyInfo))\r\n        {\r\n            if (keyInfo.ExpiresAt > DateTime.UtcNow)\r\n            {\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                _logger.LogWarning("Expired API key used: {ApiKeyId}", keyInfo.Id);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            _logger.LogWarning("Invalid API key used: {ApiKey}", apiKey[..8] + "...");\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private Dictionary<string, ApiKeyInfo> LoadApiKeysFromConfiguration()\r\n    {\r\n        var apiKeys = new Dictionary<string, ApiKeyInfo>();\r\n        var apiKeySection = _configuration.GetSection("ApiKeys");\r\n\r\n        foreach (var section in apiKeySection.GetChildren())\r\n        {\r\n            var keyInfo = new ApiKeyInfo\r\n            {\r\n                Id = section["Id"] ?? string.Empty,\r\n                Name = section["Name"] ?? string.Empty,\r\n                Key = section["Key"] ?? string.Empty,\r\n                ExpiresAt = DateTime.Parse(section["ExpiresAt"] ?? DateTime.MaxValue.ToString()),\r\n                Scopes = section.GetSection("Scopes").Get<string[]>() ?? Array.Empty<string>()\r\n            };\r\n\r\n            if (!string.IsNullOrEmpty(keyInfo.Key))\r\n            {\r\n                apiKeys[keyInfo.Key] = keyInfo;\r\n            }\r\n        }\r\n\r\n        return apiKeys;\r\n    }\r\n}\r\n\r\npublic class ApiKeyInfo\r\n{\r\n    public string Id { get; set; } = string.Empty;\r\n    public string Name { get; set; } = string.Empty;\r\n    public string Key { get; set; } = string.Empty;\r\n    public DateTime ExpiresAt { get; set; }\r\n    public string[] Scopes { get; set; } = Array.Empty<string>();\r\n}\r\n\r\n// Middleware/ApiKeyValidationMiddleware.cs\r\npublic class ApiKeyValidationMiddleware\r\n{\r\n    private readonly RequestDelegate _next;\r\n    private readonly ApiKeyValidationService _apiKeyService;\r\n    private readonly ILogger<ApiKeyValidationMiddleware> _logger;\r\n\r\n    public ApiKeyValidationMiddleware(\r\n        RequestDelegate next,\r\n        ApiKeyValidationService apiKeyService,\r\n        ILogger<ApiKeyValidationMiddleware> logger)\r\n    {\r\n        _next = next;\r\n        _apiKeyService = apiKeyService;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task InvokeAsync(HttpContext context)\r\n    {\r\n        // Skip API key validation for health checks and auth endpoints\r\n        if (context.Request.Path.StartsWithSegments("/health") ||\r\n            context.Request.Path.StartsWithSegments("/auth"))\r\n        {\r\n            await _next(context);\r\n            return;\r\n        }\r\n\r\n        var apiKey = context.Request.Headers["X-API-Key"].FirstOrDefault();\r\n\r\n        if (!string.IsNullOrEmpty(apiKey))\r\n        {\r\n            if (_apiKeyService.IsValidApiKey(apiKey, out var keyInfo))\r\n            {\r\n                // Add API key info to context for downstream services\r\n                context.Items["ApiKeyInfo"] = keyInfo;\r\n                context.Request.Headers["X-API-Key-Id"] = keyInfo!.Id;\r\n                context.Request.Headers["X-API-Key-Name"] = keyInfo.Name;\r\n\r\n                _logger.LogInformation("Valid API key used: {ApiKeyName}", keyInfo.Name);\r\n            }\r\n            else\r\n            {\r\n                context.Response.StatusCode = 401;\r\n                await context.Response.WriteAsync("Invalid API key");\r\n                return;\r\n            }\r\n        }\r\n        // If no API key provided, let it pass through for JWT validation\r\n\r\n        await _next(context);\r\n    }\r\n}\r\n\r\n// docker-compose.yml for complete setup\r\nversion: \'3.8\'\r\nservices:\r\n  api-gateway:\r\n    build:\r\n      context: ./ApiGateway\r\n      dockerfile: Dockerfile\r\n    ports:\r\n      - "5000:8080"\r\n      - "5001:8081"\r\n    environment:\r\n      - ASPNETCORE_ENVIRONMENT=Development\r\n      - ASPNETCORE_URLS=https://+:8081;http://+:8080\r\n      - Auth__Authority=https://your-identity-server\r\n      - Auth__Audience=hotel-management-api\r\n    depends_on:\r\n      - booking-service\r\n      - room-service\r\n      - customer-service\r\n    networks:\r\n      - hotel-network\r\n\r\n  booking-service:\r\n    build: ./BookingService\r\n    environment:\r\n      - ASPNETCORE_ENVIRONMENT=Development\r\n    networks:\r\n      - hotel-network\r\n\r\n  room-service:\r\n    build: ./RoomService\r\n    environment:\r\n      - ASPNETCORE_ENVIRONMENT=Development\r\n    networks:\r\n      - hotel-network\r\n\r\n  customer-service:\r\n    build: ./CustomerService\r\n    environment:\r\n      - ASPNETCORE_ENVIRONMENT=Development\r\n    networks:\r\n      - hotel-network\r\n\r\nnetworks:\r\n  hotel-network:\r\n    driver: bridge\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var t=r(6540);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);