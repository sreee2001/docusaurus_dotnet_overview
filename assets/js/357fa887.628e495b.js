"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[9500],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var t=r(6540);const o={},i=t.createContext(o);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:n},e.children)}},9732:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Topics/AdvancedTopics/CommandQueryResponsibilitySegregation","title":"CommandQueryResponsibilitySegregation","description":"55. CQRS (Command Query Responsibility Segregation)","source":"@site/docs/Topics/12_AdvancedTopics/55_CommandQueryResponsibilitySegregation.md","sourceDirName":"Topics/12_AdvancedTopics","slug":"/Topics/AdvancedTopics/CommandQueryResponsibilitySegregation","permalink":"/docusaurus_dotnet_overview/docs/Topics/AdvancedTopics/CommandQueryResponsibilitySegregation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":55,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"EventSourcing","permalink":"/docusaurus_dotnet_overview/docs/Topics/AdvancedTopics/EventSourcing"}}');var o=r(4848),i=r(8453);const a={},s=void 0,l={},d=[{value:"55. CQRS (Command Query Responsibility Segregation)",id:"55-cqrs-command-query-responsibility-segregation",level:2},{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition",id:"official-definition",level:2},{value:"Usage",id:"usage",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Market Alternatives and Adoption",id:"market-alternatives-and-adoption",level:3},{value:"Alternatives:",id:"alternatives",level:3},{value:"Pros and Cons",id:"pros-and-cons",level:3},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Sample Usage",id:"sample-usage",level:3}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"55-cqrs-command-query-responsibility-segregation",children:"55. CQRS (Command Query Responsibility Segregation)"}),"\n",(0,o.jsx)(n.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,o.jsx)(n.p,{children:"CQRS is an architectural pattern that separates read and write operations by using different models to update information and to read information. This separation allows for optimized data models and can improve performance, scalability, and security."}),"\n",(0,o.jsx)(n.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,o.jsx)(n.p,{children:"Command Query Responsibility Segregation (CQRS) is a pattern that segregates the operations that read data (Queries) from the operations that update data (Commands) by using separate interfaces. CQRS can also be used with Event Sourcing to provide a complete audit trail and enable temporal queries."}),"\n",(0,o.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,o.jsx)(n.p,{children:"CQRS is typically implemented using the MediatR library in .NET, which provides a mediator pattern implementation. Commands represent state-changing operations, while queries represent read operations."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Install required packages\r\ndotnet add package MediatR\r\ndotnet add package MediatR.Extensions.Microsoft.DependencyInjection\r\ndotnet add package FluentValidation\r\ndotnet add package FluentValidation.DependencyInjectionExtensions\n"})}),"\n",(0,o.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Applications with complex business logic that benefits from separate read/write models"}),"\n",(0,o.jsx)(n.li,{children:"Systems requiring different optimization strategies for reads vs writes"}),"\n",(0,o.jsx)(n.li,{children:"Applications needing detailed audit trails and event history"}),"\n",(0,o.jsx)(n.li,{children:"High-performance systems where read and write workloads have different scaling requirements"}),"\n",(0,o.jsx)(n.li,{children:"Domain-driven design implementations with rich business models"}),"\n",(0,o.jsx)(n.li,{children:"Systems integrating with event sourcing patterns"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Use CQRS when:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Your application has complex business logic with different read/write requirements"}),"\n",(0,o.jsx)(n.li,{children:"You need to optimize read and write operations separately"}),"\n",(0,o.jsx)(n.li,{children:"The system benefits from eventual consistency"}),"\n",(0,o.jsx)(n.li,{children:"You're implementing event sourcing or need comprehensive audit trails"}),"\n",(0,o.jsx)(n.li,{children:"Different teams work on read vs write functionality"}),"\n",(0,o.jsx)(n.li,{children:"You need to scale read and write operations independently"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Don't use CQRS when:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Your application has simple CRUD operations"}),"\n",(0,o.jsx)(n.li,{children:"The added complexity isn't justified by business requirements"}),"\n",(0,o.jsx)(n.li,{children:"You need strong consistency for all operations"}),"\n",(0,o.jsx)(n.li,{children:"Your team lacks experience with advanced architectural patterns"}),"\n",(0,o.jsx)(n.li,{children:"The application has straightforward data access patterns"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"market-alternatives-and-adoption",children:"Market Alternatives and Adoption"}),"\n",(0,o.jsx)(n.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Traditional Repository Pattern with services"}),"\n",(0,o.jsx)(n.li,{children:"Standard MVC/API controllers with direct database access"}),"\n",(0,o.jsx)(n.li,{children:"Domain-Driven Design without CQRS"}),"\n",(0,o.jsx)(n.li,{children:"Event-driven architecture without command/query separation"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Market Adoption:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Widely adopted in enterprise applications and microservices"}),"\n",(0,o.jsx)(n.li,{children:"Popular in Domain-Driven Design implementations"}),"\n",(0,o.jsx)(n.li,{children:"Supported by major frameworks (.NET, Java Spring, Node.js)"}),"\n",(0,o.jsx)(n.li,{children:"Growing adoption in cloud-native applications"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"pros-and-cons",children:"Pros and Cons"}),"\n",(0,o.jsx)(n.h3,{id:"pros",children:"Pros:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Clear separation of concerns between reads and writes"}),"\n",(0,o.jsx)(n.li,{children:"Optimized data models for different use cases"}),"\n",(0,o.jsx)(n.li,{children:"Better scalability through independent scaling of read/write sides"}),"\n",(0,o.jsx)(n.li,{children:"Enhanced security through separate permissions"}),"\n",(0,o.jsx)(n.li,{children:"Improved performance through specialized optimization"}),"\n",(0,o.jsx)(n.li,{children:"Better testability of business logic"}),"\n",(0,o.jsx)(n.li,{children:"Supports complex business workflows"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"cons",children:"Cons:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Increased architectural complexity"}),"\n",(0,o.jsx)(n.li,{children:"Potential for eventual consistency issues"}),"\n",(0,o.jsx)(n.li,{children:"More code to maintain and understand"}),"\n",(0,o.jsx)(n.li,{children:"Learning curve for development teams"}),"\n",(0,o.jsx)(n.li,{children:"Can lead to over-engineering simple scenarios"}),"\n",(0,o.jsx)(n.li,{children:"Debugging can be more complex"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"sample-usage",children:"Sample Usage"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Package references:\r\n// MediatR v12.2.0\r\n// MediatR.Extensions.Microsoft.DependencyInjection v11.1.0\r\n// FluentValidation v11.8.0\r\n// FluentValidation.DependencyInjectionExtensions v11.8.0\r\n\r\nusing MediatR;\r\nusing FluentValidation;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.EntityFrameworkCore;\r\n\r\n// Domain Model\r\npublic class Hotel\r\n{\r\n    public int Id { get; set; }\r\n    public string Name { get; set; } = string.Empty;\r\n    public string Address { get; set; } = string.Empty;\r\n    public int TotalRooms { get; set; }\r\n    public DateTime CreatedAt { get; set; }\r\n    public DateTime UpdatedAt { get; set; }\r\n}\r\n\r\n// Commands (Write Side)\r\npublic record CreateHotelCommand(string Name, string Address, int TotalRooms) : IRequest<int>;\r\n\r\npublic record UpdateHotelCommand(int Id, string Name, string Address, int TotalRooms) : IRequest<bool>;\r\n\r\npublic record DeleteHotelCommand(int Id) : IRequest<bool>;\r\n\r\n// Queries (Read Side)\r\npublic record GetHotelByIdQuery(int Id) : IRequest<HotelDto?>;\r\n\r\npublic record GetAllHotelsQuery(int Page, int PageSize) : IRequest<PaginatedResult<HotelDto>>;\r\n\r\npublic record SearchHotelsQuery(string SearchTerm, string? City) : IRequest<List<HotelDto>>;\r\n\r\n// DTOs for Read Side\r\npublic record HotelDto(int Id, string Name, string Address, int TotalRooms, DateTime CreatedAt);\r\n\r\npublic record PaginatedResult<T>(List<T> Data, int TotalCount, int Page, int PageSize);\r\n\r\n// Command Handlers\r\npublic class CreateHotelCommandHandler : IRequestHandler<CreateHotelCommand, int>\r\n{\r\n    private readonly ApplicationDbContext _context;\r\n    private readonly ILogger<CreateHotelCommandHandler> _logger;\r\n\r\n    public CreateHotelCommandHandler(ApplicationDbContext context, ILogger<CreateHotelCommandHandler> logger)\r\n    {\r\n        _context = context;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<int> Handle(CreateHotelCommand request, CancellationToken cancellationToken)\r\n    {\r\n        var hotel = new Hotel\r\n        {\r\n            Name = request.Name,\r\n            Address = request.Address,\r\n            TotalRooms = request.TotalRooms,\r\n            CreatedAt = DateTime.UtcNow,\r\n            UpdatedAt = DateTime.UtcNow\r\n        };\r\n\r\n        _context.Hotels.Add(hotel);\r\n        await _context.SaveChangesAsync(cancellationToken);\r\n\r\n        _logger.LogInformation("Created hotel {HotelName} with ID {HotelId}", hotel.Name, hotel.Id);\r\n        return hotel.Id;\r\n    }\r\n}\r\n\r\npublic class UpdateHotelCommandHandler : IRequestHandler<UpdateHotelCommand, bool>\r\n{\r\n    private readonly ApplicationDbContext _context;\r\n    private readonly ILogger<UpdateHotelCommandHandler> _logger;\r\n\r\n    public UpdateHotelCommandHandler(ApplicationDbContext context, ILogger<UpdateHotelCommandHandler> logger)\r\n    {\r\n        _context = context;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<bool> Handle(UpdateHotelCommand request, CancellationToken cancellationToken)\r\n    {\r\n        var hotel = await _context.Hotels.FindAsync(new object[] { request.Id }, cancellationToken);\r\n        if (hotel == null)\r\n            return false;\r\n\r\n        hotel.Name = request.Name;\r\n        hotel.Address = request.Address;\r\n        hotel.TotalRooms = request.TotalRooms;\r\n        hotel.UpdatedAt = DateTime.UtcNow;\r\n\r\n        await _context.SaveChangesAsync(cancellationToken);\r\n        _logger.LogInformation("Updated hotel {HotelId}", request.Id);\r\n        return true;\r\n    }\r\n}\r\n\r\n// Query Handlers\r\npublic class GetHotelByIdQueryHandler : IRequestHandler<GetHotelByIdQuery, HotelDto?>\r\n{\r\n    private readonly ApplicationDbContext _context;\r\n\r\n    public GetHotelByIdQueryHandler(ApplicationDbContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public async Task<HotelDto?> Handle(GetHotelByIdQuery request, CancellationToken cancellationToken)\r\n    {\r\n        var hotel = await _context.Hotels\r\n            .AsNoTracking()\r\n            .FirstOrDefaultAsync(h => h.Id == request.Id, cancellationToken);\r\n\r\n        return hotel == null ? null : new HotelDto(hotel.Id, hotel.Name, hotel.Address, hotel.TotalRooms, hotel.CreatedAt);\r\n    }\r\n}\r\n\r\npublic class GetAllHotelsQueryHandler : IRequestHandler<GetAllHotelsQuery, PaginatedResult<HotelDto>>\r\n{\r\n    private readonly ApplicationDbContext _context;\r\n\r\n    public GetAllHotelsQueryHandler(ApplicationDbContext context)\r\n    {\r\n        _context = context;\r\n    }\r\n\r\n    public async Task<PaginatedResult<HotelDto>> Handle(GetAllHotelsQuery request, CancellationToken cancellationToken)\r\n    {\r\n        var query = _context.Hotels.AsNoTracking();\r\n\r\n        var totalCount = await query.CountAsync(cancellationToken);\r\n\r\n        var hotels = await query\r\n            .OrderBy(h => h.Name)\r\n            .Skip((request.Page - 1) * request.PageSize)\r\n            .Take(request.PageSize)\r\n            .Select(h => new HotelDto(h.Id, h.Name, h.Address, h.TotalRooms, h.CreatedAt))\r\n            .ToListAsync(cancellationToken);\r\n\r\n        return new PaginatedResult<HotelDto>(hotels, totalCount, request.Page, request.PageSize);\r\n    }\r\n}\r\n\r\n// Validators\r\npublic class CreateHotelCommandValidator : AbstractValidator<CreateHotelCommand>\r\n{\r\n    public CreateHotelCommandValidator()\r\n    {\r\n        RuleFor(x => x.Name)\r\n            .NotEmpty().WithMessage("Hotel name is required")\r\n            .MaximumLength(200).WithMessage("Hotel name cannot exceed 200 characters");\r\n\r\n        RuleFor(x => x.Address)\r\n            .NotEmpty().WithMessage("Address is required")\r\n            .MaximumLength(500).WithMessage("Address cannot exceed 500 characters");\r\n\r\n        RuleFor(x => x.TotalRooms)\r\n            .GreaterThan(0).WithMessage("Total rooms must be greater than 0")\r\n            .LessThanOrEqualTo(10000).WithMessage("Total rooms cannot exceed 10,000");\r\n    }\r\n}\r\n\r\n// Behaviors (Cross-cutting concerns)\r\npublic class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>\r\n    where TRequest : IRequest<TResponse>\r\n{\r\n    private readonly IEnumerable<IValidator<TRequest>> _validators;\r\n\r\n    public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators)\r\n    {\r\n        _validators = validators;\r\n    }\r\n\r\n    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)\r\n    {\r\n        if (_validators.Any())\r\n        {\r\n            var context = new ValidationContext<TRequest>(request);\r\n            var validationResults = await Task.WhenAll(_validators.Select(v => v.ValidateAsync(context, cancellationToken)));\r\n            var failures = validationResults.SelectMany(r => r.Errors).Where(f => f != null).ToList();\r\n\r\n            if (failures.Any())\r\n                throw new ValidationException(failures);\r\n        }\r\n\r\n        return await next();\r\n    }\r\n}\r\n\r\npublic class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>\r\n    where TRequest : IRequest<TResponse>\r\n{\r\n    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;\r\n\r\n    public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger)\r\n    {\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)\r\n    {\r\n        var requestName = typeof(TRequest).Name;\r\n        _logger.LogInformation("Handling {RequestName}", requestName);\r\n\r\n        var stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n        try\r\n        {\r\n            var response = await next();\r\n            stopwatch.Stop();\r\n            _logger.LogInformation("Handled {RequestName} in {ElapsedMs}ms", requestName, stopwatch.ElapsedMilliseconds);\r\n            return response;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            stopwatch.Stop();\r\n            _logger.LogError(ex, "Error handling {RequestName} after {ElapsedMs}ms", requestName, stopwatch.ElapsedMilliseconds);\r\n            throw;\r\n        }\r\n    }\r\n}\r\n\r\n// Controller\r\n[ApiController]\r\n[Route("api/[controller]")]\r\npublic class HotelsController : ControllerBase\r\n{\r\n    private readonly IMediator _mediator;\r\n\r\n    public HotelsController(IMediator mediator)\r\n    {\r\n        _mediator = mediator;\r\n    }\r\n\r\n    [HttpPost]\r\n    public async Task<ActionResult<int>> CreateHotel([FromBody] CreateHotelCommand command)\r\n    {\r\n        try\r\n        {\r\n            var hotelId = await _mediator.Send(command);\r\n            return CreatedAtAction(nameof(GetHotel), new { id = hotelId }, hotelId);\r\n        }\r\n        catch (ValidationException ex)\r\n        {\r\n            return BadRequest(ex.Errors.Select(e => e.ErrorMessage));\r\n        }\r\n    }\r\n\r\n    [HttpGet("{id}")]\r\n    public async Task<ActionResult<HotelDto>> GetHotel(int id)\r\n    {\r\n        var hotel = await _mediator.Send(new GetHotelByIdQuery(id));\r\n        return hotel == null ? NotFound() : Ok(hotel);\r\n    }\r\n\r\n    [HttpGet]\r\n    public async Task<ActionResult<PaginatedResult<HotelDto>>> GetHotels([FromQuery] int page = 1, [FromQuery] int pageSize = 10)\r\n    {\r\n        var result = await _mediator.Send(new GetAllHotelsQuery(page, pageSize));\r\n        return Ok(result);\r\n    }\r\n\r\n    [HttpPut("{id}")]\r\n    public async Task<ActionResult> UpdateHotel(int id, [FromBody] UpdateHotelRequest request)\r\n    {\r\n        try\r\n        {\r\n            var command = new UpdateHotelCommand(id, request.Name, request.Address, request.TotalRooms);\r\n            var success = await _mediator.Send(command);\r\n            return success ? NoContent() : NotFound();\r\n        }\r\n        catch (ValidationException ex)\r\n        {\r\n            return BadRequest(ex.Errors.Select(e => e.ErrorMessage));\r\n        }\r\n    }\r\n\r\n    [HttpDelete("{id}")]\r\n    public async Task<ActionResult> DeleteHotel(int id)\r\n    {\r\n        var success = await _mediator.Send(new DeleteHotelCommand(id));\r\n        return success ? NoContent() : NotFound();\r\n    }\r\n}\r\n\r\npublic record UpdateHotelRequest(string Name, string Address, int TotalRooms);\r\n\r\n// DbContext\r\npublic class ApplicationDbContext : DbContext\r\n{\r\n    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }\r\n\r\n    public DbSet<Hotel> Hotels { get; set; }\r\n\r\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\r\n    {\r\n        modelBuilder.Entity<Hotel>(entity =>\r\n        {\r\n            entity.HasKey(e => e.Id);\r\n            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);\r\n            entity.Property(e => e.Address).IsRequired().HasMaxLength(500);\r\n            entity.Property(e => e.TotalRooms).IsRequired();\r\n            entity.Property(e => e.CreatedAt).IsRequired();\r\n            entity.Property(e => e.UpdatedAt).IsRequired();\r\n        });\r\n    }\r\n}\r\n\r\n// Program.cs Configuration\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add services\r\nbuilder.Services.AddControllers();\r\nbuilder.Services.AddEndpointsApiExplorer();\r\nbuilder.Services.AddSwaggerGen();\r\n\r\n// Add DbContext\r\nbuilder.Services.AddDbContext<ApplicationDbContext>(options =>\r\n    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));\r\n\r\n// Add MediatR\r\nbuilder.Services.AddMediatR(cfg => {\r\n    cfg.RegisterServicesFromAssembly(typeof(Program).Assembly);\r\n});\r\n\r\n// Add FluentValidation\r\nbuilder.Services.AddValidatorsFromAssembly(typeof(Program).Assembly);\r\n\r\n// Add behaviors\r\nbuilder.Services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));\r\nbuilder.Services.AddScoped(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));\r\n\r\nvar app = builder.Build();\r\n\r\n// Configure pipeline\r\nif (app.Environment.IsDevelopment())\r\n{\r\n    app.UseSwagger();\r\n    app.UseSwaggerUI();\r\n}\r\n\r\napp.UseHttpsRedirection();\r\napp.UseAuthorization();\r\napp.MapControllers();\r\n\r\napp.Run();\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);