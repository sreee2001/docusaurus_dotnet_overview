"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[8910],{3901:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>s});const i=JSON.parse('{"id":"Topics/Microservices/CircuitBreakerPatern","title":"CircuitBreakerPatern","description":"47. Circuit Breaker Pattern (Polly)","source":"@site/docs/Topics/10_Microservices/47_CircuitBreakerPatern.md","sourceDirName":"Topics/10_Microservices","slug":"/Topics/Microservices/CircuitBreakerPatern","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/CircuitBreakerPatern","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":47,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ServiceDiscovery","permalink":"/docusaurus_dotnet_overview/docs/Topics/Microservices/ServiceDiscovery"},"next":{"title":"IdentityServer","permalink":"/docusaurus_dotnet_overview/docs/Topics/Security/IdentityServer"}}');var t=n(4848),a=n(8453);const o={},c=void 0,l={},s=[{value:"47. Circuit Breaker Pattern (Polly)",id:"47-circuit-breaker-pattern-polly",level:2},{value:"Short Introduction",id:"short-introduction",level:2},{value:"Official Definition",id:"official-definition",level:2},{value:"Setup/Usage with .NET 8+ Code",id:"setupusage-with-net-8-code",level:2},{value:"Use Cases",id:"use-cases",level:3},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"Market Alternatives &amp; Pros/Cons",id:"market-alternatives--proscons",level:3},{value:"Alternatives:",id:"alternatives",level:3},{value:"Pros:",id:"pros",level:3},{value:"Cons:",id:"cons",level:3},{value:"Complete Runnable Sample",id:"complete-runnable-sample",level:3}];function u(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"47-circuit-breaker-pattern-polly",children:"47. Circuit Breaker Pattern (Polly)"}),"\n",(0,t.jsx)(r.h2,{id:"short-introduction",children:"Short Introduction"}),"\n",(0,t.jsx)(r.p,{children:"The Circuit Breaker pattern prevents an application from repeatedly trying to execute an operation that's likely to fail, allowing it to continue without waiting for the fault to be fixed or wasting CPU cycles. Polly is a .NET resilience and transient-fault-handling library that implements circuit breaker along with retry, timeout, bulkhead isolation, and fallback patterns."}),"\n",(0,t.jsx)(r.h2,{id:"official-definition",children:"Official Definition"}),"\n",(0,t.jsx)(r.p,{children:"The Circuit Breaker pattern is a design pattern used in software development to detect failures and encapsulates the logic of preventing a failure from constantly recurring during maintenance, temporary external system failure, or unexpected system difficulties."}),"\n",(0,t.jsx)(r.h2,{id:"setupusage-with-net-8-code",children:"Setup/Usage with .NET 8+ Code"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Install Polly:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-bash",children:"dotnet add package Polly\r\ndotnet add package Polly.Extensions.Http\r\ndotnet add package Microsoft.Extensions.Http.Polly\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Basic Circuit Breaker Setup:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// Program.cs\r\nusing Polly;\r\nusing Polly.Extensions.Http;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add Polly policies\r\nbuilder.Services.AddHttpClient<IRoomService, RoomServiceClient>(client =>\r\n{\r\n    client.BaseAddress = new Uri(builder.Configuration["Services:RoomService:BaseUrl"]);\r\n    client.Timeout = TimeSpan.FromSeconds(30);\r\n})\r\n.AddPolicyHandler(GetRetryPolicy())\r\n.AddPolicyHandler(GetCircuitBreakerPolicy())\r\n.AddPolicyHandler(GetTimeoutPolicy());\r\n\r\n// Add resilience service\r\nbuilder.Services.AddSingleton<IResilienceService, ResilienceService>();\r\n\r\nvar app = builder.Build();\r\n\r\n// Polly policies\r\nstatic IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()\r\n{\r\n    return HttpPolicyExtensions\r\n        .HandleTransientHttpError()\r\n        .WaitAndRetryAsync(\r\n            retryCount: 3,\r\n            sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),\r\n            onRetry: (outcome, timespan, retryCount, context) =>\r\n            {\r\n                var logger = context.GetLogger();\r\n                logger?.LogWarning("Retry {RetryCount} after {Delay}ms", retryCount, timespan.TotalMilliseconds);\r\n            });\r\n}\r\n\r\nstatic IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()\r\n{\r\n    return HttpPolicyExtensions\r\n        .HandleTransientHttpError()\r\n        .CircuitBreakerAsync(\r\n            handledEventsAllowedBeforeBreaking: 3,\r\n            durationOfBreak: TimeSpan.FromSeconds(30),\r\n            onBreak: (result, timespan) =>\r\n            {\r\n                Console.WriteLine($"Circuit breaker opened for {timespan}");\r\n            },\r\n            onReset: () =>\r\n            {\r\n                Console.WriteLine("Circuit breaker closed");\r\n            },\r\n            onHalfOpen: () =>\r\n            {\r\n                Console.WriteLine("Circuit breaker half-open");\r\n            });\r\n}\r\n\r\nstatic IAsyncPolicy<HttpResponseMessage> GetTimeoutPolicy()\r\n{\r\n    return Policy.TimeoutAsync<HttpResponseMessage>(10);\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Advanced Resilience Service:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// Services/ResilienceService.cs\r\nusing Polly;\r\nusing Polly.CircuitBreaker;\r\nusing Polly.Fallback;\r\nusing Polly.Retry;\r\nusing Polly.Timeout;\r\n\r\npublic interface IResilienceService\r\n{\r\n    Task<T> ExecuteAsync<T>(Func<Task<T>> operation, string operationName);\r\n    Task<T> ExecuteWithFallbackAsync<T>(Func<Task<T>> operation, Func<Task<T>> fallback, string operationName);\r\n    CircuitBreakerState GetCircuitBreakerState(string operationName);\r\n}\r\n\r\npublic class ResilienceService : IResilienceService\r\n{\r\n    private readonly ILogger<ResilienceService> _logger;\r\n    private readonly Dictionary<string, IAsyncPolicy> _policies = new();\r\n    private readonly Dictionary<string, CircuitBreakerPolicy> _circuitBreakers = new();\r\n\r\n    public ResilienceService(ILogger<ResilienceService> logger)\r\n    {\r\n        _logger = logger;\r\n        InitializePolicies();\r\n    }\r\n\r\n    public async Task<T> ExecuteAsync<T>(Func<Task<T>> operation, string operationName)\r\n    {\r\n        var policy = GetOrCreatePolicy<T>(operationName);\r\n\r\n        try\r\n        {\r\n            return await policy.ExecuteAsync(async () =>\r\n            {\r\n                _logger.LogDebug("Executing operation: {OperationName}", operationName);\r\n                return await operation();\r\n            });\r\n        }\r\n        catch (CircuitBreakerOpenException)\r\n        {\r\n            _logger.LogWarning("Circuit breaker is open for operation: {OperationName}", operationName);\r\n            throw new ServiceUnavailableException($"Service temporarily unavailable: {operationName}");\r\n        }\r\n        catch (TimeoutRejectedException)\r\n        {\r\n            _logger.LogWarning("Timeout occurred for operation: {OperationName}", operationName);\r\n            throw new TimeoutException($"Operation timed out: {operationName}");\r\n        }\r\n    }\r\n\r\n    public async Task<T> ExecuteWithFallbackAsync<T>(Func<Task<T>> operation, Func<Task<T>> fallback, string operationName)\r\n    {\r\n        var policy = GetOrCreatePolicyWithFallback<T>(operationName, fallback);\r\n\r\n        return await policy.ExecuteAsync(async () =>\r\n        {\r\n            _logger.LogDebug("Executing operation with fallback: {OperationName}", operationName);\r\n            return await operation();\r\n        });\r\n    }\r\n\r\n    public CircuitBreakerState GetCircuitBreakerState(string operationName)\r\n    {\r\n        if (_circuitBreakers.TryGetValue(operationName, out var circuitBreaker))\r\n        {\r\n            return circuitBreaker.CircuitState;\r\n        }\r\n        return CircuitBreakerState.Closed;\r\n    }\r\n\r\n    private void InitializePolicies()\r\n    {\r\n        // Initialize common policies for different operation types\r\n        CreatePolicyForOperation("database",\r\n            retryCount: 3,\r\n            circuitBreakerThreshold: 5,\r\n            circuitBreakerDuration: TimeSpan.FromMinutes(1),\r\n            timeoutDuration: TimeSpan.FromSeconds(30));\r\n\r\n        CreatePolicyForOperation("external-api",\r\n            retryCount: 2,\r\n            circuitBreakerThreshold: 3,\r\n            circuitBreakerDuration: TimeSpan.FromSeconds(30),\r\n            timeoutDuration: TimeSpan.FromSeconds(10));\r\n\r\n        CreatePolicyForOperation("internal-service",\r\n            retryCount: 2,\r\n            circuitBreakerThreshold: 4,\r\n            circuitBreakerDuration: TimeSpan.FromSeconds(45),\r\n            timeoutDuration: TimeSpan.FromSeconds(15));\r\n    }\r\n\r\n    private void CreatePolicyForOperation(string operationName, int retryCount, int circuitBreakerThreshold,\r\n        TimeSpan circuitBreakerDuration, TimeSpan timeoutDuration)\r\n    {\r\n        // Retry policy\r\n        var retryPolicy = Policy\r\n            .Handle<HttpRequestException>()\r\n            .Or<TaskCanceledException>()\r\n            .Or<TimeoutException>()\r\n            .WaitAndRetryAsync(\r\n                retryCount: retryCount,\r\n                sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),\r\n                onRetry: (outcome, timespan, retryCount, context) =>\r\n                {\r\n                    _logger.LogWarning("Retry {RetryCount} for {OperationName} after {Delay}ms",\r\n                        retryCount, operationName, timespan.TotalMilliseconds);\r\n                });\r\n\r\n        // Circuit breaker policy\r\n        var circuitBreakerPolicy = Policy\r\n            .Handle<HttpRequestException>()\r\n            .Or<TaskCanceledException>()\r\n            .Or<TimeoutException>()\r\n            .CircuitBreakerAsync(\r\n                handledEventsAllowedBeforeBreaking: circuitBreakerThreshold,\r\n                durationOfBreak: circuitBreakerDuration,\r\n                onBreak: (exception, timespan) =>\r\n                {\r\n                    _logger.LogWarning("Circuit breaker opened for {OperationName} for {Duration}ms",\r\n                        operationName, timespan.TotalMilliseconds);\r\n                },\r\n                onReset: () =>\r\n                {\r\n                    _logger.LogInformation("Circuit breaker reset for {OperationName}", operationName);\r\n                },\r\n                onHalfOpen: () =>\r\n                {\r\n                    _logger.LogInformation("Circuit breaker half-open for {OperationName}", operationName);\r\n                });\r\n\r\n        // Timeout policy\r\n        var timeoutPolicy = Policy.TimeoutAsync(timeoutDuration);\r\n\r\n        // Combine policies\r\n        var combinedPolicy = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy, timeoutPolicy);\r\n\r\n        _policies[operationName] = combinedPolicy;\r\n        _circuitBreakers[operationName] = circuitBreakerPolicy;\r\n    }\r\n\r\n    private IAsyncPolicy<T> GetOrCreatePolicy<T>(string operationName)\r\n    {\r\n        if (_policies.TryGetValue(operationName, out var policy))\r\n        {\r\n            return (IAsyncPolicy<T>)policy;\r\n        }\r\n\r\n        // Create default policy if not exists\r\n        CreatePolicyForOperation(operationName, 2, 3, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(10));\r\n        return (IAsyncPolicy<T>)_policies[operationName];\r\n    }\r\n\r\n    private IAsyncPolicy<T> GetOrCreatePolicyWithFallback<T>(string operationName, Func<Task<T>> fallback)\r\n    {\r\n        var basePolicy = GetOrCreatePolicy<T>(operationName);\r\n\r\n        var fallbackPolicy = Policy<T>\r\n            .Handle<Exception>()\r\n            .FallbackAsync(\r\n                fallbackAction: async (cancellationToken) => await fallback(),\r\n                onFallbackAsync: async (result) =>\r\n                {\r\n                    _logger.LogWarning("Fallback executed for operation: {OperationName}", operationName);\r\n                    await Task.CompletedTask;\r\n                });\r\n\r\n        return Policy.WrapAsync(fallbackPolicy, basePolicy);\r\n    }\r\n}\r\n\r\n// Exceptions/ServiceUnavailableException.cs\r\npublic class ServiceUnavailableException : Exception\r\n{\r\n    public ServiceUnavailableException(string message) : base(message) { }\r\n    public ServiceUnavailableException(string message, Exception innerException) : base(message, innerException) { }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Usage in Services:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'// Services/BookingService.cs with Circuit Breaker\r\npublic class BookingService : IBookingService\r\n{\r\n    private readonly IResilienceService _resilienceService;\r\n    private readonly HttpClient _roomServiceClient;\r\n    private readonly ILogger<BookingService> _logger;\r\n\r\n    public BookingService(\r\n        IResilienceService resilienceService,\r\n        HttpClient roomServiceClient,\r\n        ILogger<BookingService> logger)\r\n    {\r\n        _resilienceService = resilienceService;\r\n        _roomServiceClient = roomServiceClient;\r\n        _logger = logger;\r\n    }\r\n\r\n    public async Task<BookingResult> CreateBookingAsync(CreateBookingRequest request)\r\n    {\r\n        try\r\n        {\r\n            // Check room availability with circuit breaker protection\r\n            var roomAvailability = await _resilienceService.ExecuteWithFallbackAsync(\r\n                operation: async () => await CheckRoomAvailabilityAsync(request.RoomId, request.CheckIn, request.CheckOut),\r\n                fallback: async () => await GetCachedRoomAvailabilityAsync(request.RoomId),\r\n                operationName: "room-availability-check"\r\n            );\r\n\r\n            if (!roomAvailability.IsAvailable)\r\n            {\r\n                return BookingResult.Failed("Room not available");\r\n            }\r\n\r\n            // Create booking with database resilience\r\n            var booking = await _resilienceService.ExecuteAsync(\r\n                operation: async () => await SaveBookingToDatabaseAsync(request, roomAvailability.Price),\r\n                operationName: "database"\r\n            );\r\n\r\n            // Send confirmation email with fallback\r\n            await _resilienceService.ExecuteWithFallbackAsync(\r\n                operation: async () => await SendConfirmationEmailAsync(booking),\r\n                fallback: async () => await QueueEmailForLaterAsync(booking),\r\n                operationName: "email-service"\r\n            );\r\n\r\n            return BookingResult.Success(booking);\r\n        }\r\n        catch (ServiceUnavailableException ex)\r\n        {\r\n            _logger.LogError(ex, "Service unavailable during booking creation");\r\n            return BookingResult.Failed("Service temporarily unavailable. Please try again later.");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Unexpected error during booking creation");\r\n            return BookingResult.Failed("An unexpected error occurred");\r\n        }\r\n    }\r\n\r\n    private async Task<RoomAvailability> CheckRoomAvailabilityAsync(int roomId, DateTime checkIn, DateTime checkOut)\r\n    {\r\n        var response = await _roomServiceClient.PostAsJsonAsync("/api/rooms/check-availability", new\r\n        {\r\n            RoomId = roomId,\r\n            CheckIn = checkIn,\r\n            CheckOut = checkOut\r\n        });\r\n\r\n        response.EnsureSuccessStatusCode();\r\n        return await response.Content.ReadFromJsonAsync<RoomAvailability>()\r\n               ?? throw new InvalidOperationException("Invalid response from room service");\r\n    }\r\n\r\n    private async Task<RoomAvailability> GetCachedRoomAvailabilityAsync(int roomId)\r\n    {\r\n        // Fallback: return cached or default availability\r\n        _logger.LogInformation("Using fallback room availability for room {RoomId}", roomId);\r\n        return new RoomAvailability { IsAvailable = false, Price = 0 };\r\n    }\r\n\r\n    // Additional methods...\r\n}\r\n\r\n// Health check for circuit breaker status\r\npublic class CircuitBreakerHealthCheck : IHealthCheck\r\n{\r\n    private readonly IResilienceService _resilienceService;\r\n\r\n    public CircuitBreakerHealthCheck(IResilienceService resilienceService)\r\n    {\r\n        _resilienceService = resilienceService;\r\n    }\r\n\r\n    public Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)\r\n    {\r\n        var circuitBreakerStates = new Dictionary<string, object>\r\n        {\r\n            ["database"] = _resilienceService.GetCircuitBreakerState("database").ToString(),\r\n            ["external-api"] = _resilienceService.GetCircuitBreakerState("external-api").ToString(),\r\n            ["internal-service"] = _resilienceService.GetCircuitBreakerState("internal-service").ToString()\r\n        };\r\n\r\n        var hasOpenCircuitBreakers = circuitBreakerStates.Values\r\n            .Any(state => state.ToString() == CircuitBreakerState.Open.ToString());\r\n\r\n        return Task.FromResult(hasOpenCircuitBreakers\r\n            ? HealthCheckResult.Degraded("Some circuit breakers are open", null, circuitBreakerStates)\r\n            : HealthCheckResult.Healthy("All circuit breakers are closed", circuitBreakerStates));\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"External Service Calls"}),": Protect against failing external APIs"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Database Operations"}),": Prevent database overload during outages"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Microservice Communication"}),": Resilient service-to-service calls"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Resource Protection"}),": Prevent cascade failures"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Performance Degradation"}),": Handle slow or unresponsive services"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Network Instability"}),": Cope with intermittent connectivity issues"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Use Circuit Breaker when:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Calling external services or APIs"}),"\n",(0,t.jsx)(r.li,{children:"Operations can fail transiently"}),"\n",(0,t.jsx)(r.li,{children:"Failures can cascade through the system"}),"\n",(0,t.jsx)(r.li,{children:"Need automatic recovery mechanisms"}),"\n",(0,t.jsx)(r.li,{children:"Want to prevent resource exhaustion"}),"\n",(0,t.jsx)(r.li,{children:"Building distributed systems"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Consider alternatives when:"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Operations must always succeed"}),"\n",(0,t.jsx)(r.li,{children:"Failures are rare and not cascading"}),"\n",(0,t.jsx)(r.li,{children:"Simple applications with few dependencies"}),"\n",(0,t.jsx)(r.li,{children:"Performance overhead is unacceptable"}),"\n",(0,t.jsx)(r.li,{children:"Users expect immediate error feedback"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"market-alternatives--proscons",children:"Market Alternatives & Pros/Cons"}),"\n",(0,t.jsx)(r.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Hystrix"}),": Netflix's circuit breaker library (Java)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Resilience4j"}),": Lightweight fault tolerance library (Java)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Istio"}),": Service mesh with circuit breaker capabilities"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"AWS App Mesh"}),": Managed service mesh with resilience features"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Spring Cloud Circuit Breaker"}),": Spring framework integration"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Custom implementations"}),": Hand-rolled circuit breaker logic"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"pros",children:"Pros:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Prevents cascade failures"}),"\n",(0,t.jsx)(r.li,{children:"Automatic failure detection and recovery"}),"\n",(0,t.jsx)(r.li,{children:"Configurable thresholds and timeouts"}),"\n",(0,t.jsx)(r.li,{children:"Rich monitoring and metrics"}),"\n",(0,t.jsx)(r.li,{children:"Excellent .NET integration"}),"\n",(0,t.jsx)(r.li,{children:"Production-proven reliability"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"cons",children:"Cons:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Additional complexity"}),"\n",(0,t.jsx)(r.li,{children:"Potential false positives"}),"\n",(0,t.jsx)(r.li,{children:"Configuration tuning required"}),"\n",(0,t.jsx)(r.li,{children:"Memory overhead for state tracking"}),"\n",(0,t.jsx)(r.li,{children:"May mask underlying issues"}),"\n",(0,t.jsx)(r.li,{children:"Learning curve for proper usage"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"complete-runnable-sample",children:"Complete Runnable Sample"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Production-Ready Circuit Breaker Configuration:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-json",children:'{\r\n  "CircuitBreaker": {\r\n    "Policies": {\r\n      "database": {\r\n        "RetryCount": 3,\r\n        "CircuitBreakerThreshold": 5,\r\n        "CircuitBreakerDurationSeconds": 60,\r\n        "TimeoutSeconds": 30\r\n      },\r\n      "external-api": {\r\n        "RetryCount": 2,\r\n        "CircuitBreakerThreshold": 3,\r\n        "CircuitBreakerDurationSeconds": 30,\r\n        "TimeoutSeconds": 10\r\n      },\r\n      "email-service": {\r\n        "RetryCount": 1,\r\n        "CircuitBreakerThreshold": 2,\r\n        "CircuitBreakerDurationSeconds": 120,\r\n        "TimeoutSeconds": 5\r\n      }\r\n    }\r\n  }\r\n}\n'})})]})}function d(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>c});var i=n(6540);const t={},a=i.createContext(t);function o(e){const r=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:r},e.children)}}}]);