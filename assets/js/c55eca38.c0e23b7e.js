"use strict";(self.webpackChunkdotnet_overview=self.webpackChunkdotnet_overview||[]).push([[6684],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var i=r(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},9277:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Topics/PerformanceAndScalability/BackgroundServices","title":"Background Services","description":"Short Introduction and Official Definition","source":"@site/docs/Topics/06_PerformanceAndScalability/27_BackgroundServices.md","sourceDirName":"Topics/06_PerformanceAndScalability","slug":"/Topics/PerformanceAndScalability/background_services","permalink":"/docusaurus_dotnet_overview/docs/Topics/PerformanceAndScalability/background_services","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"dotnet","permalink":"/docusaurus_dotnet_overview/docs/tags/dotnet"},{"inline":true,"label":"background","permalink":"/docusaurus_dotnet_overview/docs/tags/background"},{"inline":true,"label":"services","permalink":"/docusaurus_dotnet_overview/docs/tags/services"},{"inline":true,"label":"tasks","permalink":"/docusaurus_dotnet_overview/docs/tags/tasks"},{"inline":true,"label":"scheduled","permalink":"/docusaurus_dotnet_overview/docs/tags/scheduled"},{"inline":true,"label":"jobs","permalink":"/docusaurus_dotnet_overview/docs/tags/jobs"},{"inline":true,"label":"hosted","permalink":"/docusaurus_dotnet_overview/docs/tags/hosted"}],"version":"current","sidebarPosition":27,"frontMatter":{"slug":"background_services","title":"Background Services","tags":["dotnet","background","services","tasks","scheduled","jobs","hosted"]},"sidebar":"tutorialSidebar","previous":{"title":"Caching","permalink":"/docusaurus_dotnet_overview/docs/Topics/PerformanceAndScalability/caching"},"next":{"title":"Performance Optimization","permalink":"/docusaurus_dotnet_overview/docs/Topics/PerformanceAndScalability/performance_optimization"}}');var s=r(4848),o=r(8453);const a={slug:"background_services",title:"Background Services",tags:["dotnet","background","services","tasks","scheduled","jobs","hosted"]},c="Background Services",t={},l=[{value:"Short Introduction and Official Definition",id:"short-introduction-and-official-definition",level:2},{value:"Official Definition:",id:"official-definition",level:2},{value:"Setup/Usage",id:"setupusage",level:2},{value:"Basic BackgroundService:",id:"basic-backgroundservice",level:3},{value:"With Hangfire:",id:"with-hangfire",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"When to Use vs When Not to Use",id:"when-to-use-vs-when-not-to-use",level:2},{value:"When to Use:",id:"when-to-use",level:3},{value:"When Not to Use:",id:"when-not-to-use",level:3},{value:"Alternatives and Trade-offs",id:"alternatives-and-trade-offs",level:2},{value:"Alternatives:",id:"alternatives",level:3},{value:"Trade-offs:",id:"trade-offs",level:3},{value:"Sample Code and Commands",id:"sample-code-and-commands",level:2},{value:"Basic BackgroundService:",id:"basic-backgroundservice-1",level:3},{value:"IHostedService Implementation:",id:"ihostedservice-implementation",level:3},{value:"Hangfire Example:",id:"hangfire-example",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"background-services",children:"Background Services"})}),"\n",(0,s.jsx)(n.h2,{id:"short-introduction-and-official-definition",children:"Short Introduction and Official Definition"}),"\n",(0,s.jsx)(n.p,{children:"Background services in .NET Core provide a way to run long-running tasks, scheduled jobs, and background processing outside the main request-response cycle. They enable applications to perform work continuously or on schedule without blocking user requests."}),"\n",(0,s.jsx)(n.h2,{id:"official-definition",children:"Official Definition:"}),"\n",(0,s.jsxs)(n.p,{children:["Background services are hosted services that implement ",(0,s.jsx)(n.code,{children:"IHostedService"})," or inherit from ",(0,s.jsx)(n.code,{children:"BackgroundService"})," class, allowing applications to run background tasks that start when the application starts and stop gracefully when the application shuts down."]}),"\n",(0,s.jsx)(n.h2,{id:"setupusage",children:"Setup/Usage"}),"\n",(0,s.jsx)(n.h3,{id:"basic-backgroundservice",children:"Basic BackgroundService:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Program.cs\r\nbuilder.Services.AddHostedService<DataProcessingService>();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"with-hangfire",children:"With Hangfire:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Program.cs\r\nbuilder.Services.AddHangfire(config =>\r\n{\r\n    config.UseSqlServerStorage(builder.Configuration.GetConnectionString("DefaultConnection"));\r\n});\r\n\r\nbuilder.Services.AddHangfireServer();\r\n\r\nvar app = builder.Build();\r\napp.UseHangfireDashboard("/hangfire");\n'})}),"\n",(0,s.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Processing"}),": ETL operations, file processing, data transformation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scheduled Tasks"}),": Daily reports, cleanup operations, backup processes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message Queue Processing"}),": Email sending, notification delivery, event handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitoring and Health Checks"}),": System monitoring, log cleanup, performance metrics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache Warming"}),": Preloading frequently accessed data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"External API Synchronization"}),": Periodic data sync with third-party services"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-vs-when-not-to-use",children:"When to Use vs When Not to Use"}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use",children:"When to Use:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tasks don't require immediate user feedback"}),"\n",(0,s.jsx)(n.li,{children:"Long-running operations that shouldn't block requests"}),"\n",(0,s.jsx)(n.li,{children:"Scheduled or recurring operations"}),"\n",(0,s.jsx)(n.li,{children:"Resource-intensive operations"}),"\n",(0,s.jsx)(n.li,{children:"Tasks that can tolerate some delay"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-not-to-use",children:"When Not to Use:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Real-time operations requiring immediate response"}),"\n",(0,s.jsx)(n.li,{children:"Simple, fast operations better handled in request pipeline"}),"\n",(0,s.jsx)(n.li,{children:"Operations requiring user interaction"}),"\n",(0,s.jsx)(n.li,{children:"Tasks requiring guaranteed execution order (consider message queues instead)"}),"\n",(0,s.jsx)(n.li,{children:"Memory-intensive operations on resource-constrained systems"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"alternatives-and-trade-offs",children:"Alternatives and Trade-offs"}),"\n",(0,s.jsx)(n.h3,{id:"alternatives",children:"Alternatives:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Azure Functions or AWS Lambda for serverless processing"}),"\n",(0,s.jsx)(n.li,{children:"Message queues (Azure Service Bus, RabbitMQ) for reliable processing"}),"\n",(0,s.jsx)(n.li,{children:"Windows Services or Linux daemons for system-level services"}),"\n",(0,s.jsx)(n.li,{children:"Cron jobs for simple scheduled tasks"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"trade-offs",children:"Trade-offs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Application resources vs dedicated processing services"}),"\n",(0,s.jsx)(n.li,{children:"Immediate vs delayed processing"}),"\n",(0,s.jsx)(n.li,{children:"Simple implementation vs advanced scheduling features"}),"\n",(0,s.jsx)(n.li,{children:"In-process vs out-of-process execution"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sample-code-and-commands",children:"Sample Code and Commands"}),"\n",(0,s.jsx)(n.h3,{id:"basic-backgroundservice-1",children:"Basic BackgroundService:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class DataProcessingService : BackgroundService\r\n{\r\n    private readonly ILogger<DataProcessingService> _logger;\r\n    private readonly IServiceScopeFactory _scopeFactory;\r\n\r\n    public DataProcessingService(\r\n        ILogger<DataProcessingService> logger,\r\n        IServiceScopeFactory scopeFactory)\r\n    {\r\n        _logger = logger;\r\n        _scopeFactory = scopeFactory;\r\n    }\r\n\r\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\r\n    {\r\n        while (!stoppingToken.IsCancellationRequested)\r\n        {\r\n            try\r\n            {\r\n                using var scope = _scopeFactory.CreateScope();\r\n                var dataService = scope.ServiceProvider.GetRequiredService<IDataService>();\r\n\r\n                await ProcessDataAsync(dataService);\r\n\r\n                _logger.LogInformation("Data processing completed at {Time}", DateTimeOffset.Now);\r\n\r\n                // Wait 30 minutes before next execution\r\n                await Task.Delay(TimeSpan.FromMinutes(30), stoppingToken);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                _logger.LogError(ex, "Error occurred in data processing");\r\n                await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken); // Wait before retry\r\n            }\r\n        }\r\n    }\r\n\r\n    private async Task ProcessDataAsync(IDataService dataService)\r\n    {\r\n        var unprocessedData = await dataService.GetUnprocessedDataAsync();\r\n\r\n        foreach (var item in unprocessedData)\r\n        {\r\n            await dataService.ProcessItemAsync(item);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ihostedservice-implementation",children:"IHostedService Implementation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class TimedHostedService : IHostedService, IDisposable\r\n{\r\n    private readonly ILogger<TimedHostedService> _logger;\r\n    private readonly IServiceScopeFactory _scopeFactory;\r\n    private Timer _timer;\r\n\r\n    public TimedHostedService(ILogger<TimedHostedService> logger, IServiceScopeFactory scopeFactory)\r\n    {\r\n        _logger = logger;\r\n        _scopeFactory = scopeFactory;\r\n    }\r\n\r\n    public Task StartAsync(CancellationToken cancellationToken)\r\n    {\r\n        _logger.LogInformation("Timed Hosted Service running");\r\n\r\n        _timer = new Timer(DoWork, null, TimeSpan.Zero, TimeSpan.FromHours(1));\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n\r\n    private async void DoWork(object state)\r\n    {\r\n        using var scope = _scopeFactory.CreateScope();\r\n        var reportService = scope.ServiceProvider.GetRequiredService<IReportService>();\r\n\r\n        try\r\n        {\r\n            await reportService.GenerateHourlyReportAsync();\r\n            _logger.LogInformation("Hourly report generated successfully");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, "Error generating hourly report");\r\n        }\r\n    }\r\n\r\n    public Task StopAsync(CancellationToken cancellationToken)\r\n    {\r\n        _logger.LogInformation("Timed Hosted Service is stopping");\r\n        _timer?.Change(Timeout.Infinite, 0);\r\n        return Task.CompletedTask;\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        _timer?.Dispose();\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"hangfire-example",children:"Hangfire Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Job registration\r\npublic class JobService\r\n{\r\n    public void ConfigureJobs()\r\n    {\r\n        // Fire-and-forget job\r\n        BackgroundJob.Enqueue(() => ProcessOrderAsync(123));\r\n\r\n        // Delayed job\r\n        BackgroundJob.Schedule(() => SendReminderEmail(456), TimeSpan.FromHours(24));\r\n\r\n        // Recurring job\r\n        RecurringJob.AddOrUpdate("daily-cleanup", () => CleanupTempFiles(), Cron.Daily);\r\n    }\r\n\r\n    public async Task ProcessOrderAsync(int orderId)\r\n    {\r\n        // Process order logic\r\n        await Task.Delay(1000); // Simulate work\r\n    }\r\n\r\n    public async Task SendReminderEmail(int userId)\r\n    {\r\n        // Send email logic\r\n        await Task.Delay(500);\r\n    }\r\n\r\n    public async Task CleanupTempFiles()\r\n    {\r\n        // Cleanup logic\r\n        await Task.Delay(2000);\r\n    }\r\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);